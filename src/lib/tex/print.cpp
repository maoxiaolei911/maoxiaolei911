/****************************************************************************
 **
 ** ��Ȩ���� (C) 2006-2007 ���Ĺ�˾.
 **
 ****************************************************************************/
#include <stdlib.h>
#include <malloc.h>
#include <QDateTime>
#include <QTextStream>
#include "XWApplication.h"
#include "XWTeXIODev.h"
#include "XWTeX.h"

void XWTeX::flush()
{
	switch (selector)
	{
		case TEX_TERM_AND_LOG:
		case TEX_LOG_ONLY:
		case TEX_TERM_ONLY:
		case TEX_NO_PRINT:
		case TEX_PSEUDO:
		case TEX_NEW_STRING:
			break;
			
		default:
			write_file[selector]->flush();
			break;
	}
}

void XWTeX::issueMessage()
{
	qint32 c, s;
	
	c = cur_chr; 
	link(garbage) = scanToks(false, true);
	old_setting = selector; 
	selector = TEX_NEW_STRING;
	tokenShow(def_ref); 
	selector = old_setting;
	flushList(def_ref);
	strRoom(1); 
	s = makeString();
	if (c == 0)
	{
		if ((term_offset + length(s)) > (max_print_line - 2))
			println();
		else if ((term_offset > 0) || (file_offset > 0))
			printChar(' ');
		slowPrint(s);
	}
	else
	{
		printErr(""); 
		slowPrint(s);
		if (errHelp() != TEX_NULL)
			use_err_help = true;
		else if (long_help_seen)
			help1(tr("(That was another \\errmessage.)"));
		else
		{
			if (interaction < TEX_ERROR_STOP_MODE)
				long_help_seen = true;
				
			help4(tr("This error message was generated by an \\errmessage"));
			help_line[2] = tr("command, so I can't give any explicit help.");
			help_line[1] = tr("Pretend that you're Hercule Poirot: Examine all clues,");
			help_line[0] = tr("and deduce the truth by order and method.");
			error(); 
			use_err_help = false;
		}
	}
	
	flushString();
}

void XWTeX::omegaFileWrite(qint32 fn, qint32 s)
{
	switch (write_file_mode[fn])
	{
		case TEX_NO_MODE:
		case TEX_ONEBYTE_MODE:
		case TEX_EBCDIC_MODE:
			write_file[fn]->putChar((char)xchr[(uchar)s]);
			break;
			
		case TEX_TWOBYTE_MODE:
			write_file[fn]->putChar((char)xchr[(uchar)(s / 256)]);
			write_file[fn]->putChar((char)xchr[(uchar)(s % 256)]);
			break;
			
		case TEX_TWOBYTELE_MODE:
			write_file[fn]->putChar((char)xchr[(uchar)(s % 256)]);
			write_file[fn]->putChar((char)xchr[(uchar)(s / 256)]);
			break;
	}
}

void XWTeX::omegaPrint(qint32 s)
{
	int om_mode = TEX_NO_MODE;
	int om_translation = 0;
	switch (selector)
	{
		case TEX_TERM_AND_LOG:
		case TEX_TERM_ONLY:
		case TEX_LOG_ONLY:
			om_mode = term_out_mode;
  			if (om_mode != TEX_NO_MODE) 
  				om_translation = term_out_translation;
			break;
			
		case TEX_NO_PRINT:
		case TEX_PSEUDO:
		case TEX_NEW_STRING:
			break;
			
		default:
			om_mode = write_file_mode[selector];
  			if (om_mode != TEX_NO_MODE)
  				om_translation = write_file_translation[selector];
			break;
	}
	
	if ((om_mode == TEX_NO_MODE) || 
		(om_mode == TEX_ONEBYTE_MODE && om_translation == 0))
	{
		qint32 j = str_start(s);
		while (j < str_start(s + 1))
		{
			qint32 new_s = str_pool[j];
			if (new_s < 32)
			{
				printChar('^');
				printChar('^');
				printChar(new_s + '@');
			}
			else if (new_s < 127)
				printChar(new_s);
			else if (new_s == 127)
			{
				printChar('^');
				printChar('^');
				printChar(new_s - '@');
			}
			else if (new_s < 256)
			{
				printChar('^');
				printChar('^');
				printLCHex((new_s % 256) / 16);
				printLCHex(new_s % 16);
			}
			else
			{
				printChar('^');
				printChar('^');
				printChar('^');
				printChar('^');
				printLCHex(new_s / 4096);
				printLCHex((new_s % 4096) / 256);
				printLCHex((new_s % 256) / 16);
				printLCHex(new_s % 16);
			}
			j++;
		}
	}
	else
	{
		if (om_translation == 0)
		{
			qint32 j = str_start(s);
    		otp_counter = 1;
    		while (j < str_start(s + 1))
    		{
    			otp_output_buf[otp_counter] = str_pool[j];
      			otp_counter++;
      			j++;
    		}
    		otp_output_end = otp_counter;
		}
		else
		{
			otp_input_start = 0;
    		otp_input_last  = 0;
    		otp_stack_used  = 0;
    		otp_stack_last  = 0;
    		otp_stack_new   = 0;
    		otp_output_end  = 0;
    		otp_pc = 0;
    		otp_finished = false;
    		otp_calc_ptr = 0;
    		otp_calcs[otp_calc_ptr] = 0;
    		otp_state_ptr = 0;
    		otp_states[otp_state_ptr] = 0;
    		otp_input_ocp = om_translation;
    		qint32 j = str_start(s);
    		otp_counter = 1;
    		while (j < str_start(s + 1))
    		{
    			otp_input_buf[otp_counter] = str_pool[j];
      			otp_counter++;
      			j++;
    		}
    	
    		otp_input_end = otp_counter;
    		while (!otp_finished)
    		{
    			if (otp_pc >= ocp_state_no(otp_input_ocp, otp_cur_state))
   				{
   					printErr(tr("bad OCP program -- PC not valid"));
  					succumb();
  					return ;
   				}
   			
   				otp_instruction = ocp_state_entry(otp_input_ocp, otp_cur_state, otp_pc);
				otp_instr = otp_instruction / 0x1000000;
				otp_arg = otp_instruction % 0x1000000;
			
				switch (otp_instr)
				{
					case TEX_OTP_RIGHT_OUTPUT:
						otp_output_end++;
						if (otp_output_end >ocp_buf_size)
						{
							overFlowOcpBufSize();
							return ;
						}					
						otp_output_buf[otp_output_end] = otp_calcs[otp_calc_ptr];
    					otp_calc_ptr--;
    					otp_pc++;
						break;
					
					case TEX_OTP_RIGHT_NUM:
						otp_output_end++;
						if (otp_output_end > ocp_buf_size)
						{
							overFlowOcpBufSize();
							return ;
						}
						otp_output_buf[otp_output_end] = otp_arg;
    					otp_pc++;
						break;
					
					case TEX_OTP_RIGHT_CHAR:
						if ((1 > otp_arg) || (otp_arg > otp_no_input_chars))
						{
							printErr(tr("right hand side of OCP expression is bad"));
  							succumb();
  							return ;
						}
						if (otp_arg > otp_stack_last)
							otp_calculated_char = otp_input_buf[otp_input_start + otp_arg - otp_stack_last];
						else
							otp_calculated_char = otp_stack_buf[otp_arg];
						
						otp_output_end++;
						if (otp_output_end > ocp_buf_size)
						{
							overFlowOcpBufSize();
							return ;
						}
						otp_output_buf[otp_output_end] = otp_calculated_char;
    					otp_pc++;
						break;
					
					case TEX_OTP_RIGHT_LCHAR:
						if ((1 > (otp_no_input_chars - otp_arg)) || ((otp_no_input_chars - otp_arg) > otp_no_input_chars))
						{
							printErr(tr("right hand side of OCP expression is bad"));
  							succumb();
  							return ;
						}
						if ((otp_no_input_chars - otp_arg) > otp_stack_last)
							otp_calculated_char = otp_input_buf[otp_input_start + (otp_no_input_chars - otp_arg) - otp_stack_last];
						else
							otp_calculated_char = otp_stack_buf[(otp_no_input_chars - otp_arg)];
						otp_output_end++;
						if (otp_output_end > ocp_buf_size)
						{
							overFlowOcpBufSize();
							return ;
						}
						otp_output_buf[otp_output_end] = otp_calculated_char;
    					otp_pc++;
						break;
					
					case TEX_OTP_RIGHT_SOME:
						otp_first_arg = otp_arg + 1;
    					otp_pc++;
    					if (otp_pc >= ocp_state_no(otp_input_ocp, otp_cur_state))
   						{
   							printErr(tr("bad OCP program -- PC not valid"));
  							succumb();
  							return ;
   						}
   			
   						otp_instruction = ocp_state_entry(otp_input_ocp, otp_cur_state, otp_pc);
						otp_instr = otp_instruction / 0x1000000;
						otp_arg = otp_instruction % 0x1000000;
						otp_second_arg = otp_no_input_chars - otp_arg;
						for (otp_counter = otp_first_arg; otp_counter <= otp_second_arg; otp_counter++)
						{
							if ((1 > otp_counter) || (otp_counter > otp_no_input_chars))
							{
								printErr(tr("right hand side of OCP expression is bad"));
  								succumb();
  								return ;
							}
							if (otp_counter > otp_stack_last)
								otp_calculated_char = otp_input_buf[otp_input_start + otp_counter - otp_stack_last];
							else
								otp_calculated_char = otp_stack_buf[otp_counter];
							otp_output_end++;
							if (otp_output_end > ocp_buf_size)
							{
								overFlowOcpBufSize();
								return ;
							}
							otp_output_buf[otp_output_end] = otp_calculated_char;
						}
						otp_pc++;
						break;
					
					case TEX_OTP_PBACK_OUTPUT:
						otp_stack_new++;
						if (otp_stack_new >= ocp_stack_size)
						{
							overFlowOcpStackSize();
							return ;
						}
						otp_stack_buf[otp_stack_new] = otp_calcs[otp_calc_ptr];
    					otp_calc_ptr--;
    					otp_pc++;
						break;
					
					case TEX_OTP_PBACK_NUM:
						otp_stack_new++;
						if (otp_stack_new >= ocp_stack_size)
						{
							overFlowOcpStackSize();
							return ;
						}
						otp_stack_buf[otp_stack_new] = otp_arg;
    					otp_pc++;
						break;
					
					case TEX_OTP_PBACK_CHAR:
						if ((1 > otp_arg) || (otp_arg > otp_no_input_chars))
						{
							printErr(tr("right hand side of OCP expression is bad"));
  							succumb();
  							return ;
						}
						if (otp_arg > otp_stack_last)
							otp_calculated_char = otp_input_buf[otp_input_start + otp_arg - otp_stack_last];
						else
							otp_calculated_char = otp_stack_buf[otp_arg];
						otp_stack_new++;
						if (otp_stack_new >= ocp_stack_size)
						{
							overFlowOcpStackSize();
							return ;
						}
						otp_stack_buf[otp_stack_new] = otp_calculated_char;
    					otp_pc++;
						break;
					
					case TEX_OTP_PBACK_LCHAR:
						if ((1 > (otp_no_input_chars - otp_arg)) || ((otp_no_input_chars - otp_arg) > otp_no_input_chars))
						{
							printErr(tr("right hand side of OCP expression is bad"));
  							succumb();
  							return ;
						}
						if ((otp_no_input_chars - otp_arg) > otp_stack_last)
							otp_calculated_char = otp_input_buf[otp_input_start + (otp_no_input_chars - otp_arg) - otp_stack_last];
						else
							otp_calculated_char = otp_stack_buf[(otp_no_input_chars - otp_arg)];
						otp_stack_new++;
						if (otp_stack_new >= ocp_stack_size)
						{
							overFlowOcpStackSize();
							return ;
						}
						otp_stack_buf[otp_stack_new] = otp_calculated_char;
    					otp_pc++;
						break;
					
					case TEX_OTP_PBACK_SOME:
						otp_first_arg = otp_arg + 1;
    					otp_pc++;
    					if (otp_pc >= ocp_state_no(otp_input_ocp, otp_cur_state))
   						{
   							printErr(tr("bad OCP program -- PC not valid"));
  							succumb();
  							return ;
   						}
   			
   						otp_instruction = ocp_state_entry(otp_input_ocp, otp_cur_state, otp_pc);
						otp_instr = otp_instruction / 0x1000000;
						otp_arg = otp_instruction % 0x1000000;
						otp_second_arg = otp_no_input_chars - otp_arg;
						for (otp_counter = otp_first_arg; otp_first_arg <= otp_second_arg; otp_first_arg++)
						{
							if ((1 > otp_counter) || (otp_counter > otp_no_input_chars))
							{
								printErr(tr("right hand side of OCP expression is bad"));
  								succumb();
  								return ;
							}
							if (otp_counter > otp_stack_last)
								otp_calculated_char = otp_input_buf[otp_input_start + otp_counter - otp_stack_last];
							else
								otp_calculated_char = otp_stack_buf[otp_counter];
							
							otp_stack_new++;
							if (otp_stack_new >= ocp_stack_size)
							{
								overFlowOcpStackSize();
								return ;
							}
							otp_stack_buf[otp_stack_new] = otp_calculated_char;
						}
						otp_pc++;
						break;
					
					case TEX_OTP_ADD:
						otp_calcs[otp_calc_ptr-1] = otp_calcs[otp_calc_ptr - 1] + otp_calcs[otp_calc_ptr];
    					otp_pc++;
    					otp_calc_ptr--;
						break;
					
					case TEX_OTP_SUB:
						otp_calcs[otp_calc_ptr-1] = otp_calcs[otp_calc_ptr - 1] - otp_calcs[otp_calc_ptr];
    					otp_pc++;
    					otp_calc_ptr--;
						break;
					
					case TEX_OTP_MULT:
						otp_calcs[otp_calc_ptr-1] = otp_calcs[otp_calc_ptr - 1] * otp_calcs[otp_calc_ptr];
    					otp_pc++;
    					otp_calc_ptr--;
						break;
					
					case TEX_OTP_DIV:
						otp_calcs[otp_calc_ptr-1] = otp_calcs[otp_calc_ptr - 1] / otp_calcs[otp_calc_ptr];
    					otp_pc++;
    					otp_calc_ptr--;
						break;
					
					case TEX_OTP_MOD:
						otp_calcs[otp_calc_ptr-1] = otp_calcs[otp_calc_ptr - 1] % otp_calcs[otp_calc_ptr];
    					otp_pc++;
    					otp_calc_ptr--;
						break;
					
					case TEX_OTP_LOOKUP:
						if (otp_calcs[otp_calc_ptr] >= ocp_table_no(otp_input_ocp, otp_calcs[otp_calc_ptr - 1]))
						{
							printErr("bad OCP program -- table index not valid");
      						succumb();
      						return ;
						}
						otp_calcs[otp_calc_ptr - 1] = ocp_table_entry(otp_input_ocp, otp_calcs[otp_calc_ptr - 1], otp_calcs[otp_calc_ptr]);
    					otp_pc++;
    					otp_calc_ptr--;
						break;
					
					case TEX_OTP_PUSH_NUM:
						otp_calc_ptr++;
						if (otp_calc_ptr >= ocp_stack_size)
						{
							overFlowOcpStackSize();
							return ;
						}
						otp_calcs[otp_calc_ptr] = otp_arg;
    					otp_pc++;
						break;
					
					case TEX_OTP_PUSH_CHAR:
						if ((1 > otp_arg) || (otp_arg > otp_no_input_chars))
						{
							printErr(tr("right hand side of OCP expression is bad"));
  							succumb();
  							return ;
						}
						if (otp_arg > otp_stack_last)
							otp_calculated_char = otp_input_buf[otp_input_start + otp_arg - otp_stack_last];
						else
							otp_calculated_char = otp_stack_buf[otp_arg];
						otp_calc_ptr++;
						if (otp_calc_ptr >= ocp_stack_size)
						{
							overFlowOcpStackSize();
							return ;
						}
						otp_calcs[otp_calc_ptr] = otp_calculated_char;
    					otp_pc++;
						break;
					
					case TEX_OTP_PUSH_LCHAR:
						if ((1 > (otp_no_input_chars - otp_arg)) || ((otp_no_input_chars - otp_arg) > otp_no_input_chars))
						{
							printErr(tr("right hand side of OCP expression is bad"));
  							succumb();
  							return ;
						}
						if ((otp_no_input_chars - otp_arg) > otp_stack_last)
							otp_calculated_char = otp_input_buf[otp_input_start + (otp_no_input_chars - otp_arg) - otp_stack_last];
						else
							otp_calculated_char = otp_stack_buf[(otp_no_input_chars - otp_arg)];
						otp_calc_ptr++;
						if (otp_calc_ptr >= ocp_stack_size)
						{
							overFlowOcpStackSize();
							return ;
						}
						otp_calcs[otp_calc_ptr] = otp_calculated_char;
    					otp_pc++;
						break;
					
					case TEX_OTP_STATE_CHANGE:
						otp_input_start = otp_input_last;
						for (otp_counter = 1; otp_counter <= (otp_stack_new-otp_stack_used); otp_counter++)
							otp_stack_buf[otp_counter] = otp_stack_buf[otp_counter + otp_stack_used];
						otp_stack_new = otp_stack_new - otp_stack_used;
    					otp_stack_last = otp_stack_new;
    					otp_stack_used = 0;
    					otp_states[otp_state_ptr] = otp_arg;
    					otp_pc = 0;
						break;
					
					case TEX_OTP_STATE_PUSH:
						otp_input_start = otp_input_last;
						for (otp_counter = 1; otp_counter <= (otp_stack_new-otp_stack_used); otp_counter++)
							otp_stack_buf[otp_counter] = otp_stack_buf[otp_counter + otp_stack_used];
						otp_stack_new  = otp_stack_new - otp_stack_used;
    					otp_stack_last = otp_stack_new;
    					otp_stack_used = 0;
    					otp_state_ptr++;
    					if (otp_state_ptr >= ocp_stack_size)
    					{
    						overFlowOcpStackSize();
    						return ;
    					}
    					otp_states[otp_state_ptr] = otp_arg;
    					otp_pc = 0;
						break;
					
					case TEX_OTP_STATE_POP:
						otp_input_start = otp_input_last;
						for (otp_counter = 1; otp_counter <= (otp_stack_new-otp_stack_used); otp_counter++)
							otp_stack_buf[otp_counter] = otp_stack_buf[otp_counter + otp_stack_used];
						otp_stack_new  = otp_stack_new - otp_stack_used;
    					otp_stack_last = otp_stack_new;
    					otp_stack_used = 0;
    					if (otp_state_ptr > 0)
    						otp_state_ptr--;
    					otp_pc = 0;
						break;
					
					case TEX_OTP_LEFT_START:
						otp_input_start = otp_input_last;
    					otp_input_last  = otp_input_start;
    					otp_stack_used  = 0;
    					if ((otp_stack_last == 0) && (otp_input_last >= otp_input_end))
    						otp_finished = true;
    					else if (otp_stack_used < otp_stack_last)
    					{
    						otp_stack_used++;
    						otp_input_char = otp_stack_buf[otp_stack_used];
      						otp_no_input_chars = 1;
      						otp_pc++;
    					}
    					else
    					{
    						otp_input_last++;
    						otp_input_char = otp_input_buf[otp_input_last];
      						otp_no_input_chars = 1;
      						otp_pc++;
    					}
						break;
					
					case TEX_OTP_LEFT_RETURN:
						otp_input_last = otp_input_start;
    					otp_stack_used = 0;
    					if (otp_stack_used < otp_stack_last)
    					{
    						otp_stack_used++;
    						otp_input_char = otp_stack_buf[otp_stack_used];
      						otp_no_input_chars = 1;
      						otp_pc++;
    					}
    					else
    					{
    						otp_input_last++;
    						otp_input_char = otp_input_buf[otp_input_last];
      						otp_no_input_chars = 1;
      						otp_pc++;
    					}
						break;
					
					case TEX_OTP_LEFT_BACKUP:
						if (otp_input_start < otp_input_last)
						{
							otp_input_last--; 
							otp_input_char = otp_input_buf[otp_input_last];
						}
						else
						{	
							otp_stack_used--; 
							otp_input_char = otp_stack_buf[otp_stack_used];
						}
						otp_no_input_chars--;
    					otp_pc++;
						break;
					
					case TEX_OTP_GOTO:
						otp_pc = otp_arg;
						break;
					
					case TEX_OTP_GOTO_NE:
						otp_first_arg = otp_arg;
    					otp_pc++;
    					if (otp_pc >= ocp_state_no(otp_input_ocp, otp_cur_state))
   						{
   							printErr(tr("bad OCP program -- PC not valid"));
  							succumb();
  							return ;
   						}
   			
   						otp_instruction = ocp_state_entry(otp_input_ocp, otp_cur_state, otp_pc);
						otp_instr = otp_instruction / 0x1000000;
						otp_arg = otp_instruction % 0x1000000;
						if (otp_input_char != otp_first_arg)
							otp_pc = otp_arg;
						else
							otp_pc++;
						break;
					
					case TEX_OTP_GOTO_EQ:
						otp_first_arg = otp_arg;
    					otp_pc++;
    					if (otp_pc >= ocp_state_no(otp_input_ocp, otp_cur_state))
   						{
   							printErr(tr("bad OCP program -- PC not valid"));
  							succumb();
  							return ;
   						}
   			
   						otp_instruction = ocp_state_entry(otp_input_ocp, otp_cur_state, otp_pc);
						otp_instr = otp_instruction / 0x1000000;
						otp_arg = otp_instruction % 0x1000000;
						if (otp_input_char == otp_first_arg)
							otp_pc = otp_arg;
						else
							otp_pc++;
						break;
					
					case TEX_OTP_GOTO_LT:
						otp_first_arg = otp_arg;
    					otp_pc++;
    					if (otp_pc >= ocp_state_no(otp_input_ocp, otp_cur_state))
   						{
   							printErr(tr("bad OCP program -- PC not valid"));
  							succumb();
  							return ;
   						}
   			
   						otp_instruction = ocp_state_entry(otp_input_ocp, otp_cur_state, otp_pc);
						otp_instr = otp_instruction / 0x1000000;
						otp_arg = otp_instruction % 0x1000000;
						if (otp_input_char < otp_first_arg)
							otp_pc = otp_arg;
						else
							otp_pc++;
						break;
					
					case TEX_OTP_GOTO_LE:
						otp_first_arg = otp_arg;
    					otp_pc++;
    					if (otp_pc >= ocp_state_no(otp_input_ocp, otp_cur_state))
   						{
   							printErr(tr("bad OCP program -- PC not valid"));
  							succumb();
  							return ;
   						}
   			
   						otp_instruction = ocp_state_entry(otp_input_ocp, otp_cur_state, otp_pc);
						otp_instr = otp_instruction / 0x1000000;
						otp_arg = otp_instruction % 0x1000000;
						if (otp_input_char <= otp_first_arg)
							otp_pc = otp_arg;
						else
							otp_pc++;
						break;
					
					case TEX_OTP_GOTO_GT:
						otp_first_arg = otp_arg;
    					otp_pc++;
    					if (otp_pc >= ocp_state_no(otp_input_ocp, otp_cur_state))
   						{
   							printErr(tr("bad OCP program -- PC not valid"));
  							succumb();
  							return ;
   						}
   			
   						otp_instruction = ocp_state_entry(otp_input_ocp, otp_cur_state, otp_pc);
						otp_instr = otp_instruction / 0x1000000;
						otp_arg = otp_instruction % 0x1000000;
						if (otp_input_char > otp_first_arg)
							otp_pc = otp_arg;
						else
							otp_pc++;
						break;
					
					case TEX_OTP_GOTO_GE:
						otp_first_arg = otp_arg;
    					otp_pc++;
    					if (otp_pc >= ocp_state_no(otp_input_ocp, otp_cur_state))
   						{
   							printErr(tr("bad OCP program -- PC not valid"));
  							succumb();
  							return ;
   						}
   			
   						otp_instruction = ocp_state_entry(otp_input_ocp, otp_cur_state, otp_pc);
						otp_instr = otp_instruction / 0x1000000;
						otp_arg = otp_instruction % 0x1000000;
						if (otp_input_char >= otp_first_arg)
							otp_pc = otp_arg;
						else
							otp_pc++;
						break;
					
					case TEX_OTP_GOTO_NO_ADVANCE:
						if (otp_stack_used < otp_stack_last)
						{
							otp_stack_used++;
							otp_input_char = otp_stack_buf[otp_stack_used];
      						otp_no_input_chars++;
      						otp_pc++;
						}
						else if (otp_input_last >= otp_input_end)
							otp_pc = otp_arg;
						else
						{
							otp_input_last++;
							otp_input_char = otp_input_buf[otp_input_last];
      						otp_no_input_chars++;
      						otp_pc++;
						}
						break;
					
					case TEX_OTP_GOTO_BEG:
						if (otp_input_last == 0)
							otp_pc = otp_arg;
						else
							otp_pc++;
						break;
					
					case TEX_OTP_GOTO_END:
						if (otp_input_last >= otp_input_end)
							otp_pc = otp_arg;
						else
							otp_pc++;
						break;
					
					case TEX_OTP_STOP:
						otp_input_start = otp_input_last;
						for (otp_counter = 1; otp_counter <= (otp_stack_new-otp_stack_used); otp_counter++)
							otp_stack_buf[otp_counter] = otp_stack_buf[otp_counter + otp_stack_used];
						otp_stack_new = otp_stack_new - otp_stack_used;
    					otp_stack_last = otp_stack_new;
    					otp_stack_used = 0;
    					otp_pc = 0;
						break;
					
					default:
						printErr(tr("bad OCP program -- unknown instruction"));
    					succumb();
    					return ;
						break;
				}
    	}    		
		}
		
    	for (otp_counter = 1; otp_counter <= (otp_output_end-1); otp_counter++)
    	{
    		qint32 new_s = otp_output_buf[otp_counter];
    		if ((om_mode < TEX_TWOBYTE_MODE) && (new_s > 255))
    		{
    			printChar('^');
				printChar('^');
				printChar('^');
				printChar('^');
				printLCHex(new_s / 4096);
				printLCHex((new_s % 4096) / 256);
				printLCHex((new_s % 256) / 16);
				printLCHex(new_s % 16);
    		}
    		else
    			printChar(new_s);
    	}
	}
}

void XWTeX::omegaWrite(QIODevice * f, qint32 s)
{
	switch (term_out_mode)
	{
		case TEX_NO_MODE:
		case TEX_ONEBYTE_MODE:
		case TEX_EBCDIC_MODE:
			f->putChar((char)xchr[(uchar)s]);
			break;
			
		case TEX_TWOBYTE_MODE:
			f->putChar((char)xchr[(uchar)(s / 256)]);
			f->putChar((char)xchr[(uchar)(s % 256)]);
			break;
			
		case TEX_TWOBYTELE_MODE:
			f->putChar((char)xchr[(uchar)(s % 256)]);
			f->putChar((char)xchr[(uchar)(s / 256)]);
			break;
	}
}

void XWTeX::print(const QString & str)
{
	for (int i = 0; i < str.length(); i++)
		printChar(str[i].unicode());
}

void XWTeX::print(qint32 s)
{
	if (s >= str_ptr)
		return;
	else if (s < TEX_BIGGEST_CHAR)
	{
		if (selector > TEX_PSEUDO)
		{
			printChar(s); 
			return;
		}
		
		if (s == newLineChar())
		{
			if (selector < TEX_PSEUDO)
			{
				println(); 
				return;
			}
		}
		
		qint32 nl = newLineChar();
		setNewLineChar(-1);
		if (s < 32)
		{
			printChar('^');
			printChar('^');
			printChar(s + '@');
		}
		else if (s < 127)
			printChar(s);
		else if (s == 127)
		{
			printChar('^');
			printChar('^');
			printChar(s - '@');
		}
		else if (s < 256)
		{
			printChar('^');
			printChar('^');
			printLCHex((s % 256) / 16);
			printLCHex(s % 16);
		}
		else
		{
			printChar('^');
			printChar('^');
			printChar('^');
			printChar('^');
			printLCHex(s / 4096);
			printLCHex((s % 4096) / 256);
			printLCHex((s % 256) / 16);
			printLCHex(s % 16);
		}
		
		setNewLineChar(nl);
		
		return;
	}
	
	qint32 j = str_start(s);
	while (j < str_start(s + 1))
	{
		printChar(str_pool[j]); 
		j++;
	}
}

void XWTeX::printActiveOcps()
{
	printnl(tr("Active ocps: ["));
	qint32 i = active_min_ptr;
	while (i < active_max_ptr)
	{
		print("(");
  		printScaled(active_lstack_no(i));
  		print(",");
  		printInt(active_counter(i));
  		print(",");
  		printEsc(ocpIdText(active_ocp(i)));
  		print(")");
  		if (i != (active_max_ptr - 2))
  			print(",");
  			
  		i =i + 2;
	}
	
	print("]");
}

void XWTeX::printBanner()
{
	QString productname = xwApp->getProductName();
	QString version = xwApp->getVersion();
	QString p = QString(tr("This is %1 Version %2.")).arg(productname).arg(version);
	printnl(p);
	println();
	
	QString copyright = xwApp->getCopyRight();
	printnl(copyright);
	println();
	
	if (format_ident == 0)
		print(tr(" (no format preloaded)"));
	else
	{
		slowPrint(format_ident); 
		println();
	}
	
	println();
	printInt(day()); 
	printChar(' ');
	static char months[] = " JANFEBMARAPRMAYJUNJULAUGSEPOCTNOVDEC";
	for (int k = 3 * month() - 2; k <= (3 * month()); k++)
		print(months[k]);
		
	printChar(' '); 
	printInt(year()); 
	printChar(' ');
	printTwo(time() / 60); 
	printChar(':'); 
	printTwo(time() % 60);
	println();
	
	if (eTeX_ex)
		printnl(tr("entering extended mode"));
}

void XWTeX::printChar(qint32 s)
{
	if (s == newLineChar() || s == '\n')
	{
		if (selector < TEX_PSEUDO)
		{
			println();
			return ;
		}
	}
	
	switch (selector)
	{
		case TEX_TERM_AND_LOG:
			dev->termPutChar(s);
			omegaWrite(dev->log_file, s);
			term_offset++;
			file_offset++;
			if (term_offset == max_print_line)
			{
					dev->termPutChar('\n');
				term_offset = 0;
			}
			if (file_offset == max_print_line)
			{
					dev->log_file->putChar('\n');
				file_offset = 0;
			}
			break;
			
		case TEX_LOG_ONLY:
			omegaWrite(dev->log_file, s);
			if (file_offset == max_print_line)
				println();
			break;
			
		case TEX_TERM_ONLY:
			dev->termPutChar(s);
			if (term_offset == max_print_line)
				println();
			break;
			
		case TEX_NO_PRINT:
			break;
			
		case TEX_PSEUDO:
			if (tally < trick_count)
				trick_buf[tally % error_line] = s;
			break;
			
		case TEX_NEW_STRING:
			if (pool_ptr < pool_size)
				appendChar(s);
			break;
			
		default:
			omegaFileWrite(selector, s);
			break;
	}
	
	tally++;
}

void XWTeX::printCmdChr(quint16 cmd, qint32 char_code)
{
	qint32 n = 0;
	switch (cmd)
	{
		case TEX_LEFT_BRACE: 
			chrCmd(tr("begin-group character "), char_code);
			break;
			
		case TEX_RIGHT_BRACE: 
			chrCmd(tr("end-group character "), char_code);
			break;
			
		case TEX_MATH_SHIFT: 
			chrCmd(tr("math shift character "), char_code);
			break;
			
		case TEX_MAC_PARAM: 
			chrCmd(tr("macro parameter character "), char_code);
			break;
			
		case TEX_SUP_MARK: 
			chrCmd(tr("superscript character "), char_code);
			break;
			
		case TEX_SUB_MARK: 
			chrCmd(tr("subscript character "), char_code);
			break;
			
		case TEX_ENDV: 
			print(tr("end of alignment template"));
			break;
			
		case TEX_SPACER: 
			chrCmd(tr("blank space "), char_code);
			break;
			
		case TEX_LETTER: 
			chrCmd(tr("the letter "), char_code);
			break;
			
		case TEX_OTHER_CHAR: 
			chrCmd(tr("the character "), char_code);
			break;
			
		case TEX_ASSIGN_GLUE:
		case TEX_ASSIGN_MU_GLUE:
			if (char_code < TEX_SKIP_BASE)
				printSkipParam(char_code - TEX_GLUE_BASE);
			else if (char_code < TEX_MU_SKIP_BASE)
			{
				printEsc(TeXSkip); 
				printInt(char_code - TEX_SKIP_BASE);
			}
			else
			{
				printEsc(TeXMuSkip); 
				printInt(char_code - TEX_MU_SKIP_BASE);
			}
			break;
			
		case TEX_ASSIGN_TOKS:
			if (char_code >= TEX_TOKS_BASE)
			{
				printEsc(TeXToks); 
				printInt(char_code - TEX_TOKS_BASE);
			}
			else
			{
				switch (char_code)
				{
					case TEX_OUTPUT_ROUTINE_LOC: 
						printEsc(TeXOutput);
						break;
						
  					case TEX_EVERY_PAR_LOC: 
  						printEsc(TeXEveryPar);
  						break;
  						
  					case TEX_EVERY_MATH_LOC: 
  						printEsc(TeXEveryMath);
  						break;
  						
  					case TEX_EVERY_DISPLAY_LOC: 
  						printEsc(TeXEveryDisplay);
  						break;
  						
  					case TEX_EVERY_HBOX_LOC: 
  						printEsc(TeXEveryHBox);
  						break;
  						
  					case TEX_EVERY_VBOX_LOC: 
  						printEsc(TeXEveryVBox);
  						break;
  						
  					case TEX_EVERY_JOB_LOC: 
  						printEsc(TeXEveryJob);
  						break;
  						
  					case TEX_EVERY_CR_LOC: 
  						printEsc(TeXEveryCr);
  						break;
  						
  					case TEX_EVERY_EOF_LOC: 
  						printEsc(TeXEveryEof);
  						break;
  						
  					default: 
  						printEsc(TeXErrHelp);
  						break;
				}
			}
			break;
			
		case TEX_ASSIGN_INT:
			if (char_code < TEX_COUNT_BASE)
				printParam(char_code - TEX_INT_BASE);
			else
			{
				printEsc(TeXCount); 
				printInt(char_code - TEX_COUNT_BASE);
			}
			break;
			
		case TEX_ASSIGN_DIMEN:
			if (char_code < TEX_SCALED_BASE)
				printLengthParam(char_code - TEX_DIMEN_BASE);
			else
			{
				printEsc(TeXDimen); 
				printInt(char_code - TEX_SCALED_BASE);
			}
			break;
			
		case TEX_ACCENT: 
			printEsc(TeXAccent);
			break;
			
		case TEX_ADVANCE: 
			printEsc(TeXAdvance);
			break;
			
		case TEX_AFTER_ASSIGNMENT: 
			printEsc(TeXAfterAssignment);
			break;
			
		case TEX_AFTER_GROUP: 
			printEsc(TeXAfterGroup);
			break;
			
		case TEX_ASSIGN_FONT_DIMEN: 
			if (char_code == TEX_FONT_DIMEN_CODE)
				printEsc(TeXFontDimen);
			else if (char_code == TEX_CHAR_WIDTH_CODE)
				printEsc(TeXCharWD);
			else if (char_code == TEX_CHAR_HEIGHT_CODE) 
				printEsc(TeXCharHT);
			else if (char_code == TEX_CHAR_DEPTH_CODE)
				printEsc(TeXCharDP);
			else if (char_code == TEX_CHAR_ITALIC_CODE)
				printEsc(TeXCharIT);
			else 
				print(tr("[unknown fontdimen code!]"));
			break;
			
		case TEX_BEGIN_GROUP: 
			printEsc(TeXBeginGroup);
			break;
			
		case TEX_BREAK_PENALTY: 
			printEsc(TeXPenalty);
			break;
			
		case TEX_CHAR_NUM: 
			printEsc(TeXChar);
			break;
			
		case TEX_CHAR_GHOST: 
			if (cur_chr == 0)
				printEsc(TeXLeftGHost);
  			else 
  				printEsc(TeXRightGHost);
  			break;
  			
		case TEX_CS_NAME: 
			printEsc(TeXCsName);
			break;
			
		case TEX_DEF_FONT: 
			printEsc(TeXFont);
			break;
			
		case TEX_DELIM_NUM: 
			printEsc(TeXDelimiter);
			break;
			
		case TEX_DIVIDE: 
			printEsc(TeXDivide);
			break;
			
		case TEX_END_CS_NAME: 
			printEsc(TeXEndCsName);
			break;
			
		case TEX_END_GROUP: 
			printEsc(TeXEndGroup);
			break;
			
		case TEX_EX_SPACE: 
			printEsc(' ');
			break;
			
		case TEX_EXPAND_AFTER: 
			if (char_code == 0)
				printEsc(TeXExpandAfter);
  			else
  				printEsc(TeXUnless);
  			break;
  			
		case TEX_HALIGN: 
			printEsc(TeXHAlign);
			break;
			
		case TEX_HRULE: 
			printEsc(TeXHRule);
			break;
			
		case TEX_IGNORE_SPACES: 
			printEsc(TeXIgnoreSpaces);
			break;
			
		case TEX_INSERT: 
			printEsc(TeXInsert);
			break;
			
		case TEX_ITAL_CORR: 
			printEsc('/');
			break;
			
		case TEX_MARK: 
			printEsc(TeXMark);
  			if (char_code > 0) 
  				printChar('s');
  			break;
  			
		case TEX_MATH_ACCENT: 
			printEsc(TeXMathAccent);
			break;
			
		case TEX_MATH_CHAR_NUM: 
			printEsc(TeXMathChar);
			break;
			
		case TEX_MATH_CHOICE: 
			printEsc(TeXMathChoice);
			break;
			
		case TEX_MULTIPLY: 
			printEsc(TeXMultiply);
			break;
			
		case TEX_NO_ALIGN: 
			printEsc(TeXNoAlign);
			break;
			
		case TEX_NO_BOUNDARY:
			printEsc(TeXNoBoundary);
			break;
			
		case TEX_NO_EXPAND: 
			printEsc(TeXNoExpand);
			break;
			
		case TEX_NON_SCRIPT: 
			printEsc(TeXNonScript);
			break;
			
		case TEX_OMIT: 
			printEsc(TeXOmit);
			break;
			
		case TEX_RADICAL: 
			printEsc(TeXRadical);
			break;
			
		case TEX_READ_TO_CS: 
			if (char_code == 0)
				printEsc(TeXRead);
  			else
  				printEsc(TeXReadLine);
  				
		case TEX_RELAX: 
			printEsc(TeXRelax);
			break;
			
		case TEX_SET_BOX: 
			printEsc(TeXSetBox);
			break;
			
		case TEX_SET_PREV_GRAF: 
			printEsc(TeXPrevGraf);
			break;
			
		case TEX_SET_SHAPE: 
			{
				switch (char_code)
				{
					
  					case TEX_PAR_SHAPE_LOC: 
  						printEsc(TeXParShape);
  						break;
  						
  					case TEX_INTER_LINE_PENALTIES_LOC: 
  						printEsc(TeXInterLinePenalties);
  						break;
  						
					case TEX_CLUB_PENALTIES_LOC: 
						printEsc(TeXClubPenalties);
						break;
						
					case TEX_WIDOW_PENALTIES_LOC: 
						printEsc(TeXWidowPenalties);
						break;
						
					case TEX_DISPLAY_WIDOW_PENALTIES_LOC: 
						printEsc(TeXDisplayWidowPenalties);
						break;
						
					default:
						break;
  				}
  			}
  			
		case TEX_THE: 
			if (char_code == 0)
				printEsc(TeXThe);
  			else if (char_code == 1) 
  				printEsc(TeXUnExpanded);
			else 
				printEsc(TeXDetokenize);
  			break;
  			
		case TEX_TOKS_REGISTER: 
			printEsc(TeXToks);
			if (char_code != mem_bot) 
				printSaNum(char_code);
			break;
			
		case TEX_VADJUST: 
			printEsc(TeXVAdjust);
			break;
			
		case TEX_VALIGN: 
			printEsc(TeXVAlign);
			break;
			
		case TEX_VCENTER: 
			printEsc(TeXVCenter);
			break;
			
		case TEX_VRULE: 
			printEsc(TeXVRule);
			break;
			
		case TEX_PAR_END:
			printEsc(TeXPar);
			break;
			
		case TEX_INPUT:
			if (char_code == 0)
				printEsc(TeXInput);
			else if (char_code == 2)
				printEsc(TeXScanTokens);
			else
				printEsc(TeXEndInput);
			break;
			
		case TEX_TOP_BOT_MARK:
			{
				switch (char_code % TEX_MARKS_CODE)
				{
					case TEX_FIRST_MARK_CODE: 
						printEsc(TeXFirstMark);
						break;
						
					case TEX_BOT_MARK_CODE: 
						printEsc(TeXBotMark);
						break;
						
  					case TEX_SPLIT_FIRST_MARK_CODE: 
  						printEsc(TeXSplitFirstMark);
  						break;
  						
  					case TEX_SPLIT_BOT_MARK_CODE: 
  						printEsc(TeXSplitBotMark);
  						break;
  						
  					default:
  						printEsc(TeXTopMark);
  						break;
				}
				
				if (char_code >= TEX_MARKS_CODE)
					printChar('s');
			}
			break;
			
		case TEX_REGISTER:
			if ((char_code < mem_bot) || (char_code > lo_mem_stat_max))
				cmd = sa_type(char_code);
			else
			{
				cmd = char_code - mem_bot; 
				char_code = TEX_NULL;
			}
			if (cmd == TEX_INT_VAL)
				printEsc(TeXCount);
			else if (cmd == TEX_DIMEN_VAL)
				printEsc(TeXDimen);
			else if (cmd == TEX_GLUE_VAL)
				printEsc(TeXSkip);
			else
				printEsc(TeXMuSkip);
			if (char_code != TEX_NULL)
				printSaNum(char_code);
			break;
			
		case TEX_SET_AUX:
			if (char_code == TEX_VMODE)
				printEsc(TeXPrevDepth);
			else
				printEsc(TeXSpaceFactor);
			break;
			
		case TEX_SET_PAGE_INT:
			if (char_code == 0)
				printEsc(TeXDeadCycles);
			else if (char_code == 2)
				printEsc(TeXInteractionMode);
			else
				printEsc(TeXInsertPenalties);
			break;
			
		case TEX_SET_BOX_DIMEN:
			if (char_code == TEX_WIDTH_OFFSET)
				printEsc(TeXWD);
			else if (char_code == TEX_HEIGHT_OFFSET)
				printEsc(TeXHT);
			else if (char_code == TEX_DEPTH_OFFSET)
				printEsc(TeXDP);
			else
				print(tr("[unknown box dimen!]"));
			break;
			
		case TEX_LAST_ITEM:
			{
				switch (char_code)
				{
					case TEX_INT_VAL: 
						printEsc(TeXLastPenalty);
						break;
						
  					case TEX_DIMEN_VAL: 
  						printEsc(TeXLastKern);
  						break;
  						
  					case TEX_GLUE_VAL: 
  						printEsc(TeXLastSkip);
  						break;
  						
  					case TEX_INPUT_LINE_NO_CODE: 
  						printEsc(TeXInputLineNo);
  						break;
  						
  					case TEX_LAST_NODE_TYPE_CODE: 
  						printEsc(TeXLastNodeType);
  						break;
  						
					case TEX_ALEPH_VERSION_CODE: 
						printEsc(TeXAlephversion);
						break;
						
					case TEX_OMEGA_VERSION_CODE: 
						printEsc(TeXOmegaversion);
						break;
						
					case TEX_ETEX_VERSION_CODE: 
						printEsc(TeXeTeXversion);
						break;
						
					case TEX_ALEPH_MINOR_VERSION_CODE: 
						printEsc(TeXAlephminorversion);
						break;
						
					case TEX_OMEGA_MINOR_VERSION_CODE: 
						printEsc(TeXOmegaminorversion);
						break;
						
					case TEX_ETEX_MINOR_VERSION_CODE: 
						printEsc(TeXeTeXminorversion);
						break;
						
					case TEX_CURRENT_GROUP_LEVEL_CODE: 
						printEsc(TeXCurrentGroupLevel);
						break;
						
					case TEX_CURRENT_GROUP_TYPE_CODE: 
						printEsc(TeXCurrentGroupType);
						break;
						
					case TEX_CURRENT_IF_LEVEL_CODE: 
						printEsc(TeXCurrentIfLevel);
						break;
						
					case TEX_CURRENT_IF_TYPE_CODE: 
						printEsc(TeXCurrentIfType);
						break;
						
					case TEX_CURRENT_IF_BRANCH_CODE: 
						printEsc(TeXCurrentIfBranch);
						break;
						
					case TEX_FONT_CHAR_WD_CODE: 
						printEsc(TeXFontCharWD);
						break;
						
					case TEX_FONT_CHAR_HT_CODE: 
						printEsc(TeXFontCharHT);
						break;
						
					case TEX_FONT_CHAR_DP_CODE: 
						printEsc(TeXFontCharDP);
						break;
						
					case TEX_FONT_CHAR_IC_CODE: 
						printEsc(TeXFontCharIC);
						break;
						
					case TEX_PAR_SHAPE_LENGTH_CODE: 
						printEsc(TeXParShapeLength);
						break;
						
					case TEX_PAR_SHAPE_INDENT_CODE: 
						printEsc(TeXParShapeIndent);
						break;
						
					case TEX_PAR_SHAPE_DIMEN_CODE: 
						printEsc(TeXParShapeDimen);
						break;
						
					case TEX_ETEX_EXPR - TEX_INT_VAL + TEX_INT_VAL: 
						printEsc(TeXNumExpr);
						break;
						
					case TEX_ETEX_EXPR - TEX_INT_VAL + TEX_DIMEN_VAL: 
						printEsc(TeXDimExpr);
						break;
						
					case TEX_ETEX_EXPR - TEX_INT_VAL + TEX_GLUE_VAL: 
						printEsc(TeXGlueExpr);
						break;
						
					case TEX_ETEX_EXPR - TEX_INT_VAL + TEX_MU_VAL: 
						printEsc(TeXMuExpr);
						break;
						
					case TEX_GLUE_STRETCH_ORDER_CODE: 
						printEsc(TeXGlueStretchOrder);
						break;
						
					case TEX_GLUE_SHRINK_ORDER_CODE: 
						printEsc(TeXGlueShrinkOrder);
						break;
						
					case TEX_GLUE_STRETCH_CODE: 
						printEsc(TeXGlueStretch);
						break;
						
					case TEX_GLUE_SHRINK_CODE: 
						printEsc(TeXGlueShrink);
						break;
						
					case TEX_MU_TO_GLUE_CODE: 
						printEsc(TeXMuToGlue);
						break;
						
					case TEX_GLUE_TO_MU_CODE: 
						printEsc(TeXGlueToMu);
						break;
						
					default:
						printEsc(TeXBadness);
						break;
				}
			}
			break;
			
		case TEX_CONVERT:
			{
				switch (char_code)
				{
					case TEX_NUMBER_CODE: 
						printEsc(TeXNumber);
						break;
						
  					case TEX_ROMAN_NUMERAL_CODE: 
  						printEsc(TeXRomanNumeral);
  						break;
  						
  					case TEX_STRING_CODE: 
  						printEsc(TeXString);
  						break;
  						
  					case TEX_MEANING_CODE: 
  						printEsc(TeXMeaning);
  						break;
  						
  					case TEX_FONT_NAME_CODE: 
  						printEsc(TeXFontName);
  						break;
  						
  					case TEX_ETEX_CODE: 
  						printEsc(TeXeTeXVersion);
  						break;
  						
  					case TEX_OMEGA_CODE: 
  						printEsc(TeXOmegaVersion);
  						break;
  						
  					case TEX_ALEPH_CODE: 
  						printEsc(TeXAlephVersion);
  						break;
  						
  					case TEX_JOB_NAME_CODE: 
  						printEsc(TeXJobName);
  						break;
  						
  					case TEX_ALEPH_REVISION_CODE: 
  						printEsc(TeXAlephrevision);
  						break;
  						
					case TEX_OMEGA_REVISION_CODE: 
						printEsc(TeXOmegarevision);
						break;
						
					case TEX_ETEX_REVISION_CODE: 
						printEsc(TeXeTeXrevision);
						break;
						
					default:
						print("\\???");
						break;
				}
			}
			break;
			
		case TEX_IF_TEST:
			{
				if (char_code >= TEX_UNLESS_CODE)
					printEsc(TeXUnless);
					
				switch (char_code % TEX_UNLESS_CODE)
				{
					case TEX_IF_CAT_CODE:
						printEsc(TeXIfCat);
						break;
						
  					case TEX_IF_INT_CODE:
  						printEsc(TeXIfNum);
  						break;
  						
  					case TEX_IF_DIM_CODE:
  						printEsc(TeXIfDim);
  						break;
  						
  					case TEX_IF_ODD_CODE:
  						printEsc(TeXIfOdd);
  						break;
  						
  					case TEX_IF_VMODE_CODE:
  						printEsc(TeXIfVMode);
  						break;
  						
  					case TEX_IF_HMODE_CODE:
  						printEsc(TeXIfHMode);
  						break;
  						
  					case TEX_IF_MMODE_CODE:
  						printEsc(TeXIfMMode);
  						break;
  						
  					case TEX_IF_INNER_CODE:
  						printEsc(TeXIfInner);
  						break;
  						
  					case TEX_IF_VOID_CODE:
  						printEsc(TeXIfVoid);
  						break;
  						
  					case TEX_IF_HBOX_CODE:
  						printEsc(TeXIfHBox);
  						break;
  						
  					case TEX_IF_VBOX_CODE:
  						printEsc(TeXIfVBox);
  						break;
  						
  					case TEX_IFX_CODE:
  						printEsc(TeXIfX);
  						break;
  						
  					case TEX_IF_EOF_CODE:
  						printEsc(TeXIfEof);
  						break;
  						
  					case TEX_IF_TRUE_CODE:
  						printEsc(TeXIfTrue);
  						break;
  						
  					case TEX_IF_FALSE_CODE:
  						printEsc(TeXIfFalse);
  						break;
  						
  					case TEX_IF_CASE_CODE:
  						printEsc(TeXIfCase);
  						break;
  						
  					case TEX_IF_DEF_CODE:
  						printEsc(TeXIfDefined);
  						break;
  						
					case TEX_IF_CS_CODE:
						printEsc(TeXIfCsName);
						break;
						
					case TEX_IF_FONT_CHAR_CODE:
						printEsc(TeXIfFontChar);
						break;
						
					default:
						printEsc(TeXIF);
						break;
				}
			}
			break;
			
		case TEX_FI_OR_ELSE:
			if (char_code == TEX_FI_CODE)
				printEsc(TeXFI);
			else if (char_code == TEX_OR_CODE)
				printEsc(TeXOR);
			else
				printEsc(TeXElse);
			break;
			
		case TEX_TAB_MARK:
			if (char_code == TEX_SPAN_CODE)
				printEsc(TeXSpan);
			else
				chrCmd(tr("alignment tab character "), char_code);
			break;
			
		case TEX_CAR_RET:
			if (char_code == TEX_CR_CODE)
				printEsc(TeXCr);
			else
				printEsc(TeXCrCr);
			break;
			
		case TEX_SET_PAGE_DIMEN:
			{
				switch (char_code)
				{
					case 0: 
						printEsc(TeXPageGoal);
						break;
						
					case 1: 
						printEsc(TeXPageTotal);
						break;
						
					case 2: 
						printEsc(TeXPageStretch);
						break;
						
					case 3: 
						printEsc(TeXPageFilStretch);
						break;
						
					case 4: 
						printEsc(TeXPageFillStretch);
						break;
						
					case 5: 
						printEsc(TeXPageFilllStretch);
						break;
						
					case 6: 
						printEsc(TeXPageShrink);
						break;
						
					default:
						printEsc(TeXPageDepth);
						break;
				}
			}
			break;
			
		case TEX_STOP:
			if (char_code == 1)
				printEsc(TeXDump);
			else
				printEsc(TeXEnd);
			break;
			
		case TEX_HSKIP:
			{
				switch (char_code)
				{
					case TEX_SKIP_CODE:
						printEsc(TeXHSkip);
						break;
						
  					case TEX_FIL_CODE:
  						printEsc(TeXHFil);
  						break;
  						
  					case TEX_FILL_CODE:
  						printEsc(TeXHFill);
  						break;
  						
  					case TEX_SS_CODE:
  						printEsc(TeXHSs);
  						break;
  						
  					default: 
  						printEsc(TeXHFilNeg);
  						break;
				}
			}
			break;
			
		case TEX_VSKIP:
			{
				switch (char_code)
				{
					case TEX_SKIP_CODE:
						printEsc(TeXVSkip);
						break;
						
  					case TEX_FIL_CODE:
  						printEsc(TeXVFil);
  						break;
  						
  					case TEX_FILL_CODE:
  						printEsc(TeXVFill);
  						break;
  						
  					case TEX_SS_CODE:
  						printEsc(TeXVSs);
  						break;
  						
  					default: 
  						printEsc(TeXVFilNeg);
  						break;
				}
			}
			break;
			
		case TEX_MSKIP: 
			printEsc(TeXMSkip);
			break;
			
		case TEX_KERN: 
			printEsc(TeXKern);
			break;
			
		case TEX_MKERN: 
			printEsc(TeXMKern);
			break;
			
		case TEX_HMOVE:
			if (char_code == 1)
				printEsc(TeXMoveLeft);
			else
				printEsc(TeXMoveRight);
			break;
			
		case TEX_VMOVE:
			if (char_code == 1)
				printEsc(TeXRaise);
			else
				printEsc(TeXLower);
			break;
			
		case TEX_MAKE_BOX:
			{
				switch (char_code)
				{
					case TEX_BOX_CODE: 
						printEsc(TeXBox);
						break;
						
  					case TEX_COPY_CODE: 
  						printEsc(TeXCopy);
  						break;
  						
  					case TEX_LAST_BOX_CODE: 
  						printEsc(TeXLastBox);
  						break;
  						
  					case TEX_VSPLIT_CODE: 
  						printEsc(TeXVSplit);
  						break;
  						
  					case TEX_VTOP_CODE: 
  						printEsc(TeXVTop);
  						break;
  						
  					case TEX_VTOP_CODE + TEX_VMODE: 
  						printEsc(TeXVBox);
  						break;
  						
  					default:
  						printEsc(TeXHBox);
  						break;
				}
			}
			break;
			
		case TEX_LEADER_SHIP:
			if (char_code == TEX_A_LEADERS)
				printEsc(TeXLeaders);
			else if (char_code == TEX_C_LEADERS)
				printEsc(TeXCLeaders);
			else if (char_code == TEX_X_LEADERS)
				printEsc(TeXXLeaders);
			else
				printEsc(TeXShipOut);
			break;
			
		case TEX_START_PAR:
			if (char_code == 0)
				printEsc(TeXNoIndent);
			else
				printEsc(TeXIndent);
			break;
			
		case TEX_REMOVE_ITEM:
			if (char_code == TEX_GLUE_NODE)
				printEsc(TeXUnSkip);
			else if (char_code == TEX_KERN_NODE)
				printEsc(TeXUnKern);
			else
				printEsc(TeXUnPenalty);
			break;
			
		case TEX_UN_HBOX:
			if (char_code == TEX_COPY_CODE)
				printEsc(TeXUnHCopy);
			else
				printEsc(TeXUnHBox);
			break;
			
		case TEX_UN_VBOX:
			if (char_code == TEX_COPY_CODE)
				printEsc(TeXUnVCopy);
			else if (char_code == TEX_LAST_BOX_CODE)
				printEsc(TeXPageDiscards);
			else if (char_code == TEX_VSPLIT_CODE)
				printEsc(TeXSplitDiscards);
			else
				printEsc(TeXUnVBox);
			break;
			
		case TEX_DISCRETIONARY:
			if (char_code == 1)
				printEsc(TeXDiscret);
			else
				printEsc(TeXDiscretionary);
			break;
			
		case TEX_ASSIGN_LOCAL_BOX:
			if (char_code == 0)
				printEsc(TeXLocalLeftBox);
			else
				printEsc(TeXLocalRightBox);
			break;
			
		case TEX_EQ_NO:
			if (char_code == 1)
				printEsc(TeXLEqNo);
			else
				printEsc(TeXEqNo);
			break;
			
		case TEX_MATH_COMP:
			{
				switch (char_code)
				{
					case TEX_ORD_NOAD: 
						printEsc(TeXMathOrd);
						break;
						
  					case TEX_OP_NOAD: 
  						printEsc(TeXMathOp);
  						break;
  						
  					case TEX_BIN_NOAD: 
  						printEsc(TeXMathBin);
  						break;
  						
  					case TEX_REL_NOAD: 
  						printEsc(TeXMathRel);
  						break;
  						
  					case TEX_OPEN_NOAD: 
  						printEsc(TeXMathOpen);
  						break;
  						
  					case TEX_CLOSE_NOAD: 
  						printEsc(TeXMathClose);
  						break;
  						
  					case TEX_PUNCT_NOAD: 
  						printEsc(TeXMathPunct);
  						break;
  						
  					case TEX_INNER_NOAD: 
  						printEsc(TeXMathInner);
  						break;
  						
  					case TEX_UNDER_NOAD: 
  						printEsc(TeXUnderLine);
  						break;
  						
  					default: 
  						printEsc(TeXOverLine);
  						break;
				}
			}
			break;
			
		case TEX_LIMIT_SWITCH:
			if (char_code == TEX_LIMITS)
				printEsc(TeXLimits);
			else if (char_code == TEX_NO_LIMITS)
				printEsc(TeXNoLimits);
			else
				printEsc(TeXDisplayLimits);
			break;
			
		case TEX_MATH_STYLE:
			printStyle(char_code);
			break;
			
		case TEX_ABOVE:
			{
				switch (char_code)
				{
					case TEX_OVER_CODE:
						printEsc(TeXOver);
						break;
						
  					case TEX_ATOP_CODE:
  						printEsc(TeXATop);
  						break;
  						
  					case TEX_DELIMITED_CODE + TEX_ABOVE_CODE:
  						printEsc(TeXAboveWithDelims);
  						break;
  						
  					case TEX_DELIMITED_CODE + TEX_OVER_CODE:
  						printEsc(TeXOverWithDelims);
  						break;
  						
  					case TEX_DELIMITED_CODE + TEX_ATOP_CODE:
  						printEsc(TeXATopWithDelims);
  						break;
  						
  					default:
  						printEsc(TeXAbove);
  						break;
				}
			}
			break;
			
		case TEX_LEFT_RIGHT:
			if (char_code == TEX_LEFT_NOAD)
				printEsc(TeXLeft);
			else if (char_code == TEX_MIDDLE_NOAD)
				printEsc(TeXMiddle);
			else
				printEsc(TeXRight);
			break;
			
		case TEX_PREFIX:
			if (char_code == 1)
				printEsc(TeXLong);
			else if (char_code == 2)
				printEsc(TeXOuter);
			else if (char_code == 8)
				printEsc(TeXProtected);
			else
				printEsc(TeXGlobal);
			break;
			
		case TEX_DEF:
			if (char_code == 0)
				printEsc(TeXDef);
			else if (char_code == 1)
				printEsc(TeXGDef);
			else if (char_code == 2)
				printEsc(TeXEDef);
			else
				printEsc(TeXXDef);
			break;
			
		case TEX_LET:
			if (char_code != TEX_NORMAL)
				printEsc(TeXFutureLet);
			else
				printEsc(TeXLet);
			break;
			
		case TEX_SHORTHAND_DEF:
			{
				switch (char_code)
				{
					case TEX_CHAR_DEF_CODE: 
						printEsc(TeXCharDef);
						break;
						
  					case TEX_MATH_CHAR_DEF_CODE: 
  						printEsc(TeXMathCharDef);
  						break;
  						
  					case TEX_COUNT_DEF_CODE: 
  						printEsc(TeXCountDef);
  						break;
  						
  					case TEX_DIMEN_DEF_CODE: 
  						printEsc(TeXDimenDef);
  						break;
  						
  					case TEX_SKIP_DEF_CODE: 
  						printEsc(TeXSkipDef);
  						break;
  						
  					case TEX_MU_SKIP_DEF_CODE: 
  						printEsc(TeXMuSkipDef);
  						break;
  						
  					default:
  						printEsc(TeXToksDef);
  						break;
				}
			}
			break;
			
		case TEX_CHAR_GIVEN:
			printEsc(TeXChar); 
			printHex(char_code);
			break;
			
		case TEX_MATH_GIVEN:
			printEsc(TeXMathChar); 
			printHex(char_code);
			break;
			
		case TEX_DEF_CODE:
			if (char_code == TEX_CAT_CODE_BASE)
				printEsc(TeXCatCode);
			else if (char_code == TEX_MATH_CODE_BASE)
				printEsc(TeXMathCode);
			else if (char_code == TEX_LC_CODE_BASE)
				printEsc(TeXLcCode);
			else if (char_code == TEX_UC_CODE_BASE)
				printEsc(TeXUcCode);
			else if (char_code == TEX_SF_CODE_BASE)
				printEsc(TeXSfCode);
			else
				printEsc(TeXDelCode);
			break;
			
		case TEX_DEF_FAMILY:
			printSize(char_code - TEX_MATH_FONT_BASE);
			break;
			
		case TEX_HYPH_DATA:
			if (char_code == 1)
				printEsc(TeXPatterns);
			else
				printEsc(TeXHyphenation);
			break;
			
		case TEX_ASSIGN_FONT_INT:
			if (char_code == 0)
				printEsc(TeXHyphenChar);
			else
				printEsc(TeXSkewChar);
			break;
			
		case TEX_SET_FONT:
			print(tr("select font ")); 
			slowPrint(font_name(char_code));
			if (font_size(char_code) != font_dsize(char_code))
			{
				print(" at "); 
				printScaled(font_size(char_code));
    			print(TeXPT);
			}
			break;
			
		case TEX_SET_INTERACTION:
			{
				switch (char_code)
				{
					case TEX_BATCH_MODE: 
						printEsc(TeXBatchMode);
						break;
						
  					case TEX_NONSTOP_MODE: 
  						printEsc(TeXNonStopMode);
  						break;
  						
  					case TEX_SCROLL_MODE: 
  						printEsc(TeXScrollMode);
  						break;
  						
  					default:
  						printEsc(TeXErrorStopMode);
  						break;
				}
			}
			break;
			
		case TEX_IN_STREAM:
			if (char_code == 0)
				printEsc(TeXCloseIn);
			else
				printEsc(TeXOpenIn);
			break;
			
		case TEX_MESSAGE:
			if (char_code == 0)
				printEsc(TeXMessage);
			else
				printEsc(TeXErrMessage);
			break;
			
		case TEX_CASE_SHIFT:
			if (char_code == TEX_LC_CODE_BASE)
				printEsc(TeXLowerCase);
			else
				printEsc(TeXUpperCase);
			break;
			
		case TEX_XRAY:
			{
				switch (char_code)
				{
					case TEX_SHOW_BOX_CODE:
						printEsc(TeXShowBox);
						break;
						
  					case TEX_SHOW_THE_CODE:
  						printEsc(TeXShowThe);
  						break;
  						
  					case TEX_SHOW_LISTS:
  						printEsc(TeXShowLists);
  						break;
  						
  					case TEX_SHOW_GROUPS:
  						printEsc(TeXShowGroups);
  						break;
  						
  					case TEX_SHOW_TOKENS:
  						printEsc(TeXShowTokens);
  						break;
  						
  					case TEX_SHOW_IFS:
  						printEsc(TeXShowIfs);
  						break;
  						
  					default:
  						printEsc(TeXShow);
  						break;
				}
			}
			break;
			
		case TEX_UNDEFINED_CS: 
			print(tr("undefined"));
			break;
			
		case TEX_CALL:
		case TEX_LONG_CALL:
		case TEX_OUTER_CALL:
		case TEX_LONG_OUTER_CALL:
			n = cmd - TEX_CALL;
			if (info(link(char_code)) == TEX_PROTECTED_TOKEN)
				n = n + 4;
			if (odd(n / 4))
				printEsc(TeXProtected);
			if (odd(n))
				printEsc(TeXLong);
			if (odd(n / 2))
				printEsc(TeXOuter);
			if (n > 0)
				printChar(' ');
			print("macro");
			break;
			
		case TEX_END_TEMPLATE: 
			printEsc("outer endtemplate");
			break;
			
		case TEX_EXTENSION:
			{
				switch (char_code)
				{
					case TEX_OPEN_NODE:
						printEsc(TeXOpenOut);
						break;
						
  					case TEX_WRITE_NODE:
  						printEsc(TeXWrite);
  						break;
  						
  					case TEX_CLOSE_NODE:
  						printEsc(TeXCloseOut);
  						break;
  						
  					case TEX_SPECIAL_NODE:
  						printEsc(TeXSpecial);
  						break;
  						
  					case TEX_IMMEDIATE_CODE:
  						printEsc(TeXImmediate);
  						break;
  						
  					case TEX_SET_LANGUAGE_CODE:
  						printEsc(TeXSetLanguage);
  						break;
  						
  					default:
  						print(tr("[unknown extension!]"));
  						break;
				}
			}
			break;
			
		case TEX_CHAR_TRANS:
			{
				switch (char_code)
				{
					case TEX_TRANS_INPUT:
						printEsc(TeXInputTranslation);
						break;
						
  					case TEX_TRANS_OUTPUT:
  						printEsc(TeXOutputTranslation);
  						break;
  						
  					case TEX_TRANS_DEFAULT_INPUT:
  						printEsc(TeXDefaultInputTranslation);
  						break;
  						
  					case TEX_TRANS_DEFAULT_OUTPUT:
  						printEsc(TeXDefaultOutputTranslation);
  						break;
  						
  					case TEX_TRANS_NO_INPUT:
  						printEsc(TeXnoInputTranslation);
  						break;
  						
  					case TEX_TRANS_NO_OUTPUT:
  						printEsc(TeXnoOutputTranslation);
  						break;
  						
  					case TEX_TRANS_NO_DEFAULT_INPUT:
  						printEsc(TeXnoDefaultInputTranslation);
  						break;
  						
  					case TEX_TRANS_NO_DEFAULT_OUTPUT: 
  						printEsc(TeXnoDefaultOutputTranslation);
  						break;
  						
  					default:
  						break;
				}
			}
			break;
			
		case TEX_CHAR_MODE:
			{
				switch (char_code)
				{
					case TEX_MODE_INPUT:
						printEsc(TeXInputMode);
						break;
						
  					case TEX_MODE_OUTPUT:
  						printEsc(TeXOutputMode);
  						break;
  						
  					case TEX_MODE_DEFAULT_INPUT:
  						printEsc(TeXDefaultInputMode);
  						break;
  						
  					case TEX_MODE_DEFAULT_OUTPUT:
  						printEsc(TeXDefaultOutputMode);
  						break;
  						
  					case TEX_MODE_NO_INPUT:
  						printEsc(TeXnoInputMode);
  						break;
  						
  					case TEX_MODE_NO_OUTPUT:
  						printEsc(TeXnoOutputMode);
  						break;
  						
  					case TEX_MODE_NO_DEFAULT_INPUT:
  						printEsc(TeXnoDefaultInputMode);
  						break;
  						
  					case TEX_MODE_NO_DEFAULT_OUTPUT:
  						printEsc(TeXnoDefaultOutputMode);
  						break;
  						
  					default:
  						break;
				}
			}
			break;
			
		case TEX_SET_OCP:
			print(tr("select ocp "));
  			slowPrint(ocp_name(char_code));
			break;
			
		case TEX_DEF_OCP:
			if (cur_chr == 0)
				printEsc(TeXOCP);
			else
				printEsc(TeXExternalOcp);
			break;
			
		case TEX_SET_OCP_LIST: 
			print(tr("select ocp list "));
			break;
			
		case TEX_DEF_OCP_LIST:  
			printEsc(TeXOcpList);
			break;
			
		case TEX_PUSH_OCP_LIST: 
			printEsc(TeXPushOcpList);
			break;
			
		case TEX_POP_OCP_LIST:  
			printEsc(TeXPopOcpList);
			break;
			
		case TEX_CLEAR_OCP_LISTS: 
			printEsc(TeXClearOcpLists);
			break;
			
		case TEX_OCP_LIST_OP:
			if (char_code == TEX_ADD_BEFORE_OP)
				printEsc(TeXAddBeforeOcpList);
			else if (char_code == TEX_ADD_AFTER_OP)
				printEsc(TeXAddAfterOcpList);
			else if (char_code == TEX_REMOVE_BEFORE_OP)
				printEsc(TeXRemoveBeforeOcpList);
			else
				printEsc(TeXRemoveAfterOcpList);
			break;
			
		case TEX_OCP_TRACE_LEVEL: 
			printEsc(TeXOcpTraceLevel);
			break;
			
		default:
			print(tr("[unknown command code!]"));
			break;
	}
}

void XWTeX::printCS(qint32 p)
{
	if (p < TEX_HASH_BASE)
	{
		if (p >= TEX_SINGLE_BASE)
		{
			if (p == TEX_NULL_CS)
			{
				printEsc(TeXCsName); 
				printEsc(TeXEndCsName);
			}
			else
			{
				printEsc(p - TEX_SINGLE_BASE);
				if (catCode(p - TEX_SINGLE_BASE) == TEX_LETTER)
					printChar(' ');
			}
		}
		else if (p < TEX_ACTIVE_BASE)
			printEsc(TeXIMPOSSIBLE);
		else
			print(p - TEX_ACTIVE_BASE);
	}
	else if (p >= TEX_UNDEFINED_CONTROL_SEQUENCE)
		printEsc(TeXIMPOSSIBLE);
	else if (newText(p) >= str_ptr)
		printEsc(TeXNONEXISTENT);
	else
	{
		printEsc(newText(p));
  		printChar(' ');
	}
}

void XWTeX::printCsNames(qint32 hstart, qint32 hfinish)
{
	QString msg = QString(tr("fmtdebug:csnames from %1 to %2: ")).arg(hstart).arg(hfinish);
	printnl(msg);
	for (qint32 h = hstart; h <= hfinish; h++)
	{
		if (newText(h) > 0)
		{
			for (qint32 c = str_start(newText(h)); c < str_start(newText(h) + 1); c++)
				printChar(str_pool[c]);
				
			print("|");
		}
	}
}

void XWTeX::printCurrentString()
{
	qint32 j = str_start(str_ptr);
	while (j < pool_ptr)
	{
		printChar(str_pool[j]); 
		j++;
	}
}

void XWTeX::printDelimiter(qint32 p)
{
	qint32 a = small_fam(p) * 256 + small_char(p);
	a = a * 0x1000 + large_fam(p) * 256 + large_char(p);
	if (a < 0)
		printInt(a);
	else
		printHex(a);
}

void XWTeX::printDir(qint32 d)
{
	print(dir_names[dir_primary[d]]);
	print(dir_names[dir_secondary[d]]);
	print(dir_names[dir_tertiary[d]]);
}

void XWTeX::printErr(const QString & str)
{
	if ((file_line_error_style_p && !terminal_input))
		printFileLineStyleLineAndFile();
	else
		printnl("! ");
		
	print(str);
}

void XWTeX::printEsc(qint32 s)
{
	qint32 c = escapeChar();
	if (c >= 0)
	{
		if (c <= TEX_BIGGEST_CHAR)
			print(c);
	}
	
	slowPrint(s);
}

void XWTeX::printEsc(const QString & s)
{
	qint32 c = escapeChar();
	if (c >= 0)
	{
		if (c <= TEX_BIGGEST_CHAR)
			print(c);
	}
	
	print(s);
}

void XWTeX::printFamAndChar(qint32 p)
{
	printEsc(TeXFam); 
	printInt(fam(p)); 
	printChar(' ');
	print(character(p));
}

void XWTeX::printFileLineStyleLineAndFile()
{
	qint32 l = in_open;
	while (l > 0 && full_source_filename_stack[l] == 0)
		l--;
	if (l == 0)
		print("! ");
	else
	{
		printnl ("");
		print(full_source_filename_stack[l]);
		print(":"); 
		if (l == in_open)
  		printInt(line); 
  	else
  		printInt(line_stack[index + 1 - (in_open - l)]);
  	print (": ");
  }
}

void XWTeX::printFileName(qint32 n, qint32 a, qint32 e)
{
	if (a >= 0)
		slowPrint(a);
		
	if (n >= 0)
		slowPrint(n);
		
	if (e >= 0)
		slowPrint(e);
}

void XWTeX::printFontAndChar(qint32 p)
{
	if (p > mem_end)
		printEsc(TeXCLOBBERED);
	else
	{
		printEsc(fontIdText(font(p)));
			
		printChar(' ');
		print(character(p));
	}
}

void XWTeX::printGlue(qint32 d, qint32 order, qint32 s)
{
	printScaled(d);
	if ((order < TEX_NORMAL) || (order > TEX_FILLL))
		print("foul");
	else if (order > TEX_NORMAL)
	{
		print("fi");
		while (order > TEX_SFI)
		{
			printChar('l'); 
			order--;
		}
	}
	else if (s != 0)
		print(s);
}

void XWTeX::printGlue(qint32 d, qint32 order, const QString & s)
{
	printScaled(d);
	if ((order < TEX_NORMAL) || (order > TEX_FILLL))
		print("foul");
	else if (order > TEX_NORMAL)
	{
		print("fi");
		while (order > TEX_SFI)
		{
			printChar('l'); 
			order--;
		}
	}
	else if (s != 0)
		print(s);
}

void XWTeX::printGroup(bool e)
{
	switch (cur_group)
	{
		case TEX_BOTTOM_LEVEL:
			print(tr("bottom level")); 
			return;
			break;
			
		case TEX_SIMPLE_GROUP:
		case TEX_SEMI_SIMPLE_GROUP:
			if (cur_group == TEX_SEMI_SIMPLE_GROUP)
				print(tr("semi "));
			print(tr("simple"));
			break;
			
		case TEX_HBOX_GROUP:
		case TEX_ADJUSTED_HBOX_GROUP:
			if (cur_group == TEX_ADJUSTED_HBOX_GROUP)
				print(tr("adjusted "));
    		print(tr("hbox"));
			break;
			
		case TEX_VBOX_GROUP: 
			print(tr("vbox"));
			break;
			
  		case TEX_VTOP_GROUP: 
  			print(tr("vtop"));
  			break;
  			
  		case TEX_ALIGN_GROUP:
  		case TEX_NO_ALIGN_GROUP:
  			if (cur_group == TEX_NO_ALIGN_GROUP)
  				print(tr("no "));
    		print(tr("align"));
  			break;
  			
  		case TEX_OUTPUT_GROUP: 
  			print(tr("output"));
  			break;
  			
  		case TEX_DISC_GROUP: 
  			print(tr("disc"));
  			break;
  			
  		case TEX_INSERT_GROUP: 
  			print(tr("insert"));
  			break;
  			
  		case TEX_VCENTER_GROUP: 
  			print(tr("vcenter"));
  			break;
  			
  		case TEX_MATH_GROUP:
  		case TEX_MATH_CHOICE_GROUP:
  		case TEX_MATH_SHIFT_GROUP:
  		case TEX_MATH_LEFT_GROUP:
  			print(tr("math"));
  			if (cur_group == TEX_MATH_CHOICE_GROUP)
  				print(tr(" choice"));
  			else if (cur_group == TEX_MATH_SHIFT_GROUP)
  				print(tr(" shift"));
  			else if (cur_group == TEX_MATH_LEFT_GROUP)
  				print(tr(" left"));
  			break;
  			
  		default:
  			break;
	}
	
	print(tr(" group (level ")); 
	printInt(cur_level); 
	printChar(')');
	if (saved(-1) != 0)
	{
		if (e)
			print(tr(" entered at line "));
		else
			print(" at line ");
	}
	
	printInt(saved(-1));
}

void XWTeX::printHex(qint32 n)
{
	char k = 0;
	printChar('"');
	do
	{
		dig[k] = n % 16; 
		n = n / 16; 
		k++;
	} while (n != 0);
	
	printTheDigs(k);
}

void  XWTeX::printIfLine(qint32 l)
{
	if (l != 0)
	{
		print(tr(" entered on line ")); 
		printInt(l);
	}
}

void XWTeX::printInt(qint32 n)
{
	char k = 0;
	if (n < 0)
	{
		printChar('-');
		if (n > -100000000)
			n = -n;
		else
		{
			qint32 m = -1 - n; 
			n = m / 10; 
			m = (m % 10) + 1; 
			k = 1;
			if (m < 10)
				dig[0] = m;
			else
			{
				dig[0] = 0; 
				n++;
			}
		}
	}
	
	do
	{
		dig[k] = n % 10; 
		n = n / 10; 
		k++;
	} while (n != 0);
	
	printTheDigs(k);
}

void XWTeX::printLengthParam(qint32 n)
{
	switch (n)
	{
		case TEX_PAR_INDENT_CODE:
			printEsc(TeXParIndent);
			break;
			
		case TEX_MATH_SURROUND_CODE:
			printEsc(TeXMathSurround);
			break;
			
		case TEX_LINE_SKIP_LIMIT_CODE:
			printEsc(TeXLineSkipLimit);
			break;
			
		case TEX_HSIZE_CODE:
			printEsc(TeXHSize);
			break;
			
		case TEX_VSIZE_CODE:
			printEsc(TeXVSize);
			break;
			
		case TEX_MAX_DEPTH_CODE:
			printEsc(TeXMaxDepth);
			break;
			
		case TEX_SPLIT_MAX_DEPTH_CODE:
			printEsc(TeXSplitMaxDepth);
			break;
			
		case TEX_BOX_MAX_DEPTH_CODE:
			printEsc(TeXBoxMaxDepth);
			break;
			
		case TEX_HFUZZ_CODE:
			printEsc(TeXHFuzz);
			break;
			
		case TEX_VFUZZ_CODE:
			printEsc(TeXVFuzz);
			break;
			
		case TEX_DELIMITER_SHORTFALL_CODE:
			printEsc(TeXDelimiterShortFall);
			break;
			
		case TEX_NULL_DELIMITER_SPACE_CODE:
			printEsc(TeXNullDelimiterSpace);
			break;
			
		case TEX_SCRIPT_SPACE_CODE:
			printEsc(TeXScriptSpace);
			break;
			
		case TEX_PRE_DISPLAY_SIZE_CODE:
			printEsc(TeXPredisplaySize);
			break;
			
		case TEX_DISPLAY_WIDTH_CODE:
			printEsc(TeXDisplayWidth);
			break;
			
		case TEX_DISPLAY_INDENT_CODE:
			printEsc(TeXDisplayIndent);
			break;
			
		case TEX_OVERFULL_RULE_CODE:
			printEsc(TeXOverFullRule);
			break;
			
		case TEX_HANG_INDENT_CODE:
			printEsc(TeXHangIndent);
			break;
			
		case TEX_H_OFFSET_CODE:
			printEsc(TeXHOffset);
			break;
			
		case TEX_V_OFFSET_CODE:
			printEsc(TeXVOffset);
			break;
			
		case TEX_EMERGENCY_STRETCH_CODE:
			printEsc(TeXEmergencyStretch);
			break;
			
		case TEX_PAGE_WIDTH_CODE:
			printEsc(TeXPageWidth);
			break;
			
		case TEX_PAGE_HEIGHT_CODE:
			printEsc(TeXPageHeight);
			break;
			
		case TEX_PAGE_RIGHT_OFFSET_CODE:
			printEsc(TeXPageRightOffset);
			break;
			
		case TEX_PAGE_BOTTOM_OFFSET_CODE:
			printEsc(TeXPageBottomOffset);
			break;
			
		default:
			print(tr("[unknown dimen parameter!]"));
			break;
	}
}

void XWTeX::println()
{
	switch (selector)
	{
		case TEX_TERM_AND_LOG:
			dev->termPutChar('\n');
			dev->log_file->putChar('\n');
			term_offset = 0; 
			file_offset = 0;
			break;
			
		case TEX_LOG_ONLY:
			dev->log_file->putChar('\n');
			file_offset = 0;
			break;
			
		case TEX_TERM_ONLY:
			dev->termPutChar('\n');
			term_offset = 0; 
			break;
			
		case TEX_NO_PRINT:
		case TEX_PSEUDO:
		case TEX_NEW_STRING:
			break;
			
		default:
			write_file[selector]->putChar('\n');
			break;
	}
}

void XWTeX::printMark(qint32 p)
{
	printChar('{');
	if ((p < hi_mem_min) || (p > mem_end))
		printEsc(TeXCLOBBERED);
	else
		showTokenList(link(p), TEX_NULL, max_print_line - 10);
		
	printChar('}');
}

void XWTeX::printMeaning()
{
	printCmdChr((quint16)cur_cmd, cur_chr);
	if (cur_cmd >= TEX_CALL)
	{
		printChar(':'); 
		println(); 
		tokenShow(cur_chr);
	}
	else if ((cur_cmd == TEX_TOP_BOT_MARK) && (cur_chr < TEX_MARKS_CODE))
	{
		printChar(':'); 
		println();
  		tokenShow(cur_mark[cur_chr]);
	}
}

void XWTeX::printMode(qint32 m)
{
	if (m > 0)
	{
		switch ((m / (TEX_MAX_COMMAND + 1)))
		{
			case 0:
				print(tr("vertical"));
				break;
				
			case 1:
				print(tr("horizontal"));
				break;
				
			case 2:
				print(tr("display math"));
				break;
		}
	}
	else if (m == 0)
		print(tr("no"));
	else
	{
		switch ((-m) / (TEX_MAX_COMMAND + 1))
		{
			case 0:
				print(tr("internal vertical"));
				break;
				
			case 1:
				print(tr("restricted horizontal"));
				break;
				
			case 2:
				print(tr("math"));
				break;
		}
	}
	
	print(tr("mode"));
}

void XWTeX::printnl(qint32 s)
{
	if ((term_offset > 0 && odd(selector)) || 
		(file_offset > 0 && selector >= TEX_LOG_ONLY))
	{
		println();
	}
	
	print(s);
}

void XWTeX::printnl(const QString & s)
{
	if ((term_offset > 0 && odd(selector)) || 
		(file_offset > 0 && selector >= TEX_LOG_ONLY))
	{
		println();
	}
	
	print(s);
}

void XWTeX::printOcpList(qint32 list_entry)
{
	print("["); 
	qint32 p = list_entry;
	while (!(isNullOcpList(p)))
	{
		print("(");
  		printScaled(ocp_list_lstack_no(p));
  		print(" : ");
  		printOcpLStack(ocp_list_lstack(p));
  		print(")");
  		p = ocp_list_lnext(p);
  		if (!(isNullOcpList(p)))
  			print(", ");
	}
	print("]");
}

void XWTeX::printOcpLStack(qint32 lstack_entry)
{
	qint32 p = lstack_entry;
	while (p != 0)
	{
		printEsc(ocpIdText(ocp_lstack_ocp(p)));
  		p = ocp_lstack_lnext(p);
  		if (p != 0)
  			print(",");
	}
}

void XWTeX::printParam(qint32 n)
{
	switch (n)
	{
		case TEX_PRETOLERANCE_CODE:
			printEsc(TeXPreTolerance);
			break;
			
		case TEX_TOLERANCE_CODE:
			printEsc(TeXTolerance);
			break;
			
		case TEX_LINE_PENALTY_CODE:
			printEsc(TeXLinePenalty);
			break;
			
		case TEX_HYPHEN_PENALTY_CODE:
			printEsc(TeXHyphenPenalty);
			break;
			
		case TEX_EX_HYPHEN_PENALTY_CODE:
			printEsc(TeXExhyphenPenalty);
			break;
			
		case TEX_CLUB_PENALTY_CODE:
			printEsc(TeXClubPenalty);
			break;
			
		case TEX_WIDOW_PENALTY_CODE:
			printEsc(TeXWidowPenalty);
			break;
			
		case TEX_DISPLAY_WIDOW_PENALTY_CODE:
			printEsc(TeXDisplayWidowPenalty);
			break;
			
		case TEX_BROKEN_PENALTY_CODE:
			printEsc(TeXBrokenPenalty);
			break;
			
		case TEX_BIN_OP_PENALTY_CODE:
			printEsc(TeXBinOpPenalty);
			break;
			
		case TEX_REL_PENALTY_CODE:
			printEsc(TeXRelPenalty);
			break;
			
		case TEX_PRE_DISPLAY_PENALTY_CODE:
			printEsc(TeXPredisplayPenalty);
			break;
			
		case TEX_POST_DISPLAY_PENALTY_CODE:
			printEsc(TeXPostdisplayPenalty);
			break;
			
		case TEX_INTER_LINE_PENALTY_CODE:
			printEsc(TeXInterLinePenalty);
			break;
			
		case TEX_DOUBLE_HYPHEN_DEMERITS_CODE:
			printEsc(TeXDoubleHyphenDemerits);
			break;
			
		case TEX_FINAL_HYPHEN_DEMERITS_CODE:
			printEsc(TeXFinalHyphenDemerits);
			break;
			
		case TEX_ADJ_DEMERITS_CODE:
			printEsc(TeXAdjDemerits);
			break;
			
		case TEX_MAG_CODE:
			printEsc(TeXMag);
			break;
			
		case TEX_DELIMITER_FACTOR_CODE:
			printEsc(TeXDelimiterFactor);
			break;
			
		case TEX_LOOSENESS_CODE:
			printEsc(TeXLooseness);
			break;
			
		case TEX_TIME_CODE:
			printEsc(TeXTime);
			break;
			
		case TEX_DAY_CODE:
			printEsc(TeXDay);
			break;
			
		case TEX_MONTH_CODE:
			printEsc(TeXMonth);
			break;
			
		case TEX_YEAR_CODE:
			printEsc(TeXYear);
			break;
			
		case TEX_SHOW_BOX_BREADTH_CODE:
			printEsc(TeXShowBoxBreadth);
			break;
			
		case TEX_SHOW_BOX_DEPTH_CODE:
			printEsc(TeXShowBoxDepth);
			break;
			
		case TEX_HBADNESS_CODE:
			printEsc(TeXHBadness);
			break;
			
		case TEX_VBADNESS_CODE:
			printEsc(TeXVBadness);
			break;
			
		case TEX_PAUSING_CODE:
			printEsc(TeXPausing);
			break;
			
		case TEX_TRACING_ONLINE_CODE:
			printEsc(TeXTracingOnline);
			break;
			
		case TEX_TRACING_MACROS_CODE:
			printEsc(TeXTracingMacros);
			break;
			
		case TEX_TRACING_STATS_CODE:
			printEsc(TeXTracingStats);
			break;
			
		case TEX_TRACING_PARAGRAPHS_CODE:
			printEsc(TeXTracingParagraphs);
			break;
			
		case TEX_TRACING_PAGES_CODE:
			printEsc(TeXTracingPages);
			break;
			
		case TEX_TRACING_OUTPUT_CODE:
			printEsc(TeXTracingOutput);
			break;
			
		case TEX_TRACING_LOST_CHARS_CODE:
			printEsc(TeXTracingLostChars);
			break;
			
		case TEX_TRACING_COMMANDS_CODE:
			printEsc(TeXTracingCommands);
			break;
			
		case TEX_TRACING_RESTORES_CODE:
			printEsc(TeXTracingRestores);
			break;
			
		case TEX_UC_HYPH_CODE:
			printEsc(TeXUcHyph);
			break;
			
		case TEX_OUTPUT_PENALTY_CODE:
			printEsc(TeXOutputPenalty);
			break;
			
		case TEX_MAX_DEAD_CYCLES_CODE:
			printEsc(TeXMaxDeadCycles);
			break;
			
		case TEX_HANG_AFTER_CODE:
			printEsc(TeXHangAfter);
			break;
			
		case TEX_FLOATING_PENALTY_CODE:
			printEsc(TeXFloatingPenalty);
			break;
			
		case TEX_GLOBAL_DEFS_CODE:
			printEsc(TeXGlobalDefs);
			break;
			
		case TEX_CUR_FAM_CODE:
			printEsc(TeXFam);
			break;
			
		case TEX_ESCAPE_CHAR_CODE:
			printEsc(TeXEscapeChar);
			break;
			
		case TEX_DEFAULT_HYPHEN_CHAR_CODE:
			printEsc(TeXDefaultHyphenChar);
			break;
			
		case TEX_DEFAULT_SKEW_CHAR_CODE:
			printEsc(TeXDefaultSkewChar);
			break;
			
		case TEX_END_LINE_CHAR_CODE:
			printEsc(TeXEndLineChar);
			break;
			
		case TEX_NEW_LINE_CHAR_CODE:
			printEsc(TeXNewLineChar);
			break;
			
		case TEX_LANGUAGE_CODE:
			printEsc(TeXLanguage);
			break;
			
		case TEX_LEFT_HYPHEN_MIN_CODE:
			printEsc(TeXLeftHyphenMin);
			break;
			
		case TEX_RIGHT_HYPHEN_MIN_CODE:
			printEsc(TeXRightHyphenMin);
			break;
			
		case TEX_HOLDING_INSERTS_CODE:
			printEsc(TeXHoldingInserts);
			break;
			
		case TEX_ERROR_CONTEXT_LINES_CODE:
			printEsc(TeXErrorContextLines);
			break;
			
		case TEX_TRACING_ASSIGNS_CODE:
			printEsc(TeXTracingAssigns);
			break;
			
		case TEX_TRACING_GROUPS_CODE:
			printEsc(TeXTracingGroups);
			break;
			
		case TEX_TRACING_IFS_CODE:
			printEsc(TeXTracingIfs);
			break;
			
		case TEX_TRACING_SCAN_TOKENS_CODE:
			printEsc(TeXTracingScanTokens);
			break;
			
		case TEX_TRACING_NESTING_CODE:
			printEsc(TeXTracingNesting);
			break;
			
		case TEX_PRE_DISPLAY_DIRECTION_CODE:
			printEsc(TeXPredisplayDirection);
			break;
			
		case TEX_LAST_LINE_FIT_CODE:
			printEsc(TeXLastLineFit);
			break;
			
		case TEX_SAVING_VDISCARDS_CODE:
			printEsc(TeXSavingVDiscards);
			break;
			
		case TEX_SAVING_HYPH_CODES_CODE:
			printEsc(TeXSavingHyphCodes);
			break;
			
		default:
			print(tr("[unknown integer parameter!]"));
			break;
	}
}

void XWTeX::printRomanInt(qint32 n)
{
	static char str[] = "m2d5c2l5x2v5i";
	qint32 v = 1000;
	char len = (char)(strlen(str));
	char j = 0;
	while (j < len)
	{
		while (n >= v)
		{
			printChar(str[j]);
			n = n - v;
		}
		
		if (n <= 0)
			return ;
			
		char k = j + 2; 
		qint32 u = v / (str[k - 1] - '0');
		if (str[k - 1] == '2')
		{
			k = k + 2; 
			u = u / (str[k - 1] - '0');
		}
		
		if ((n + u) >= v)
		{
			printChar(str[k]); 
			n = n + u;
		}
		else
		{
			j = j + 2; 
			v = v / (str[j - 1] - '0');
		}
	}
}

void XWTeX::printRuleDimen(qint32 d)
{
	if (isNodeRunning(d))
		printChar('*');
	else
		printScaled(d);
}

void XWTeX::printSaNum(qint32 q)
{
	qint32 n;
	if (false)
		n = sa_num(q);
	else
	{
		n = hex_dig4(sa_index(q)); 
		q = link(q); 
		n = n + 16 * sa_index(q);
  		q = link(q); 
  		n = n + 256 * (sa_index(q) + 16 * sa_index(link(q)));
	}
	
	printInt(n);
}

void XWTeX::printScaled(qint32 s)
{
	if (s < 0)
	{
		printChar('-'); 
		s = -s;
	}
	
	printInt(s / TEX_UNITY);
	printChar('.');
	s = 10 * (s % TEX_UNITY) + 5; 
	qint32 delta = 10;
	
	do
	{
		if (delta > TEX_UNITY)
			s = s + 32768 - 50000;
			
		printChar('0' + (s / TEX_UNITY)); 
		s = 10 * (s % TEX_UNITY); 
		delta = delta * 10;
	} while (s > delta);
}

void XWTeX::printSize(qint32 s)
{
	if (s == 0)
		printEsc(TeXTextFont);
	else if (s == TEX_SCRIPT_SIZE)
		printEsc(TeXScriptFont);
	else
		printEsc(TeXScriptScriptFont);
}

void XWTeX::printSkipParam(qint32 n)
{
	switch (n)
	{
		case TEX_LINE_SKIP_CODE: 
			printEsc(TeXLineSkip);
			break;
			
		case TEX_BASELINE_SKIP_CODE: 
			printEsc(TeXBaseLineSkip);
			break;
			
		case TEX_PAR_SKIP_CODE: 
			printEsc(TeXParSkip);
			break;
			
		case TEX_ABOVE_DISPLAY_SKIP_CODE: 
			printEsc(TeXAboveDisplaySkip);
			break;
			
		case TEX_BELOW_DISPLAY_SKIP_CODE: 
			printEsc(TeXBelowDisplaySkip);
			break;
			
		case TEX_ABOVE_DISPLAY_SHORT_SKIP_CODE: 
			printEsc(TeXAboveDisplayShortSkip);
			break;
			
		case TEX_BELOW_DISPLAY_SHORT_SKIP_CODE: 
			printEsc(TeXBelowDisplayShortSkip);
			break;
			
		case TEX_LEFT_SKIP_CODE: 
			printEsc(TeXLeftSkip);
			break;
			
		case TEX_RIGHT_SKIP_CODE: 
			printEsc(TeXRightSkip);
			break;
			
		case TEX_TOP_SKIP_CODE: 
			printEsc(TeXTopSkip);
			break;
			
		case TEX_SPLIT_TOP_SKIP_CODE: 
			printEsc(TeXSplitTopSkip);
			break;
			
		case TEX_TAB_SKIP_CODE: 
			printEsc(TeXTabSkip);
			break;
			
		case TEX_SPACE_SKIP_CODE: 
			printEsc(TeXSpaceSkip);
			break;
			
		case TEX_XSPACE_SKIP_CODE: 
			printEsc(TeXXSpaceSkip);
			break;
			
		case TEX_PAR_FILL_SKIP_CODE: 
			printEsc(TeXParFillSkip);
			break;
			
		case TEX_THIN_MU_SKIP_CODE: 
			printEsc(TeXThinMuSkip);
			break;
			
		case TEX_MED_MU_SKIP_CODE: 
			printEsc(TeXMedMuSkip);
			break;
			
		case TEX_THICK_MU_SKIP_CODE: 
			printEsc(TeXThickMuSkip);
			break;
			
		default:
			print(tr("[unknown glue parameter!]"));
			break;
	}
}

void XWTeX::printSpec(qint32 p, qint32 s)
{
	if ((p < mem_min) || (p >= lo_mem_max))
		printChar('*');
	else
	{
		printScaled(width(p));
		if (s != 0)
			print(s);
			
		if (stretch(p) != 0)
		{
			print(tr(" plus "));
			printGlue(stretch(p), stretch_order(p), s);
		}
		
		if (shrink(p) != 0)
		{
			print(tr(" minus ")); 
			printGlue(shrink(p), shrink_order(p), s);
		}
	}
}

void XWTeX::printSpec(qint32 p, const QString & s)
{
	if ((p < mem_min) || (p >= lo_mem_max))
		printChar('*');
	else
	{
		printScaled(width(p));
		if (s != 0)
			print(s);
			
		if (stretch(p) != 0)
		{
			print(tr(" plus "));
			printGlue(stretch(p), stretch_order(p), s);
		}
		
		if (shrink(p) != 0)
		{
			print(tr(" minus ")); 
			printGlue(shrink(p), shrink_order(p), s);
		}
	}
}

void XWTeX::printStyle(qint32 c)
{
	switch (c / 2)
	{
		case 0:
			printEsc(TeXDisplayStyle);
			break;
			
		case 1:
			printEsc(TeXTextStyle);
			break;
			
		case 2:
			printEsc(TeXScriptStyle);
			break;
			
		case 3:
			printEsc(TeXScriptScriptStyle);
			break;
			
		default:
			print(tr("Unknown style!"));
			break;
	}
}

void XWTeX::printSubsidiaryData(qint32 p, qint32 c)
{
	if (curLength() >= depth_threshold)
	{
		if (math_type(p) != TEX_EMPTY)
			print(" []");
	}
	else
	{
		appendChar(c);
		temp_ptr = p;
		switch (math_type(p))
		{
			case TEX_MATH_CHAR:
				println(); 
				printCurrentString(); 
				printFamAndChar(p);
				break;
				
			case TEX_SUB_BOX:
				showInfo();
				break;
				
			case TEX_SUB_MLIST:
				if (info(p) == TEX_NULL)
				{
					println(); 
					printCurrentString(); 
					print("{}");
				}
				else
					showInfo();
				break;
				
			default:
				break;
		}
		
		flushChar();
	}
}

void XWTeX::printTheDigs(char k)
{
	while (k > 0)
	{
		k--;
		if (dig[k] < 10)
			printChar('0' + dig[k]);
		else
			printChar('A' - 10 + dig[k]);
	}
}

void XWTeX::printTotals()
{
	printScaled(page_total);
	if (page_so_far[2] != 0)
	{
		print(" plus "); 
		printScaled(page_so_far[2]); 
		print("");
	}
	
	if (page_so_far[3] != 0)
	{
		print(" plus "); 
		printScaled(page_so_far[3]); 
		print("fil");
	}
	
	if (page_so_far[4] != 0)
	{
		print(" plus "); 
		printScaled(page_so_far[4]); 
		print("fill");
	}
	
	if (page_so_far[5] != 0)
	{
		print(" plus "); 
		printScaled(page_so_far[5]); 
		print("filll");
	}
	
	if (page_shrink != 0)
	{
		print(" minus "); 
		printScaled(page_shrink);
	}
}

void XWTeX::printTwo(qint32 n)
{
	n = qAbs(n) % 100; 
	printChar('0' + (n / 10));
	printChar('0' + (n % 10));
}

void XWTeX::printWriteWhatsIt(qint32 s, qint32 p)
{
	printEsc(s);
	if (write_stream(p) < 16)
		printInt(write_stream(p));
	else if (write_stream(p) == 16)
		printChar('*');
	else
		printChar('-');
}

#ifdef XW_TEX_DEBUG

void XWTeX::printWord(const TeXMemoryWord & w)
{
	printInt(w.ii.CINT0);
	printChar(' ');
	printScaled(w.ii.CINT0); 
	printChar(' ');
	printScaled(round((double)TEX_UNITY * (w.gg.GLUE))); 
	println();
	printInt(w.hh.v.LH); 
	printChar('='); 
	printInt(w.hh.u.B0); 
	printChar(':');
	printInt(w.hh.u.B1); 
	printChar(';'); 
	printInt(w.hh.v.RH); 
	printChar(' ');
	printInt(w.qqqq.u.B0); 
	printChar(':'); 
	printInt(w.qqqq.u.B1); 
	printChar(':');
	printInt(w.qqqq.u.B2); 
	printChar(':'); 
	printInt(w.qqqq.u.B3);
}

#endif //XW_TEX_DEBUG

#ifdef XW_TEX_STAT

void XWTeX::restoreTrace(qint32 p, const QString & s)
{
	beginDiagnostic(); 
	printChar('{'); 
	print(s); 
	printChar(' ');
	showEqtb(p); 
	printChar('}');
	endDiagnostic(false);
}

#endif //XW_TEX_STAT

void XWTeX::shortDisplay(qint32 p)
{
	while (p > mem_min)
	{
		if (isCharNode(p))
		{
			if (p <= mem_end)
			{
				if (font(p) != (quint16)font_in_short_display)
				{
					printEsc(fontIdText(font(p)));
					
					printChar(' '); 
					font_in_short_display = font(p);
				}
				
				print(character(p));
			}
		}
		else
		{
			qint32 n = 0;
			switch (type(p))
			{
				case TEX_HLIST_NODE:
				case TEX_VLIST_NODE:
				case TEX_INS_NODE:
				case TEX_WHATSIT_NODE:
				case TEX_MARK_NODE:
				case TEX_ADJUST_NODE:
				case TEX_UNSET_NODE:
					print("[]");
					break;
								
				case TEX_RULE_NODE:
					printChar('|');
					break;
								
				case TEX_GLUE_NODE:
					if (glue_ptr(p) != zero_glue)
						printChar(' ');
					break;
								
				case TEX_MATH_NODE:
					printChar('$');
					break;
								
				case TEX_LIGATURE_NODE:
					shortDisplay(lig_ptr(p));
					break;
								
				case TEX_DISC_NODE:
					shortDisplay(pre_break(p));
					shortDisplay(post_break(p));
					n = replace_count(p);
					while (n > 0)
					{
						if (link(p) != TEX_NULL)
							p = link(p);
						n--;
					}
					break;
								
				default:
					break;
			}
		}
		
		p = link(p);
	}
}

void XWTeX::showActivities()
{
	nest[nest_ptr] = cur_list;
	printnl(""); 
	println();
	for (qint32 p = nest_ptr; p >= 0; p--)
	{
		qint32 m = nest[p].mode_field; 
		TeXMemoryWord a = nest[p].aux_field;
		printnl("### "); 
		printMode(m);
		print(tr(" entered at line ")); 
		printInt(qAbs(nest[p].ml_field));
		if (m == TEX_HMODE)
		{
			if (nest[p].pg_field != 8585216)
			{
				print(tr(" (language"));
				printInt(nest[p].pg_field % 65536);
				print(tr(":hyphenmin"));
				printInt(nest[p].pg_field / 4194304);
				printChar(',');
				printInt((nest[p].pg_field / 65536) % 64);
				printChar(')');
			}
		}
		
		if (nest[p].ml_field < 0)
			print(tr(" (\\output routine)"));
			
		if (p == 0)
		{
			if (page_head != page_tail)
			{
				printnl(tr("### current page:"));
				if (output_active)
					print(tr(" (held over for next output)"));
					
				showBox(link(page_head));
				if (page_contents > TEX_EMPTY)
				{
					printnl(tr("total height ")); 
					printTotals();
					printnl(tr(" goal height ")); 
					printScaled(page_goal);
					qint32 r = link(page_ins_head);
					while (r != page_ins_head)
					{
						println(); 
						printEsc(TeXInsert); 
						qint32 t = subtype(r);
						printInt(t); 
						print(tr(" adds "));
						t = xOverN(height(r), 1000) * count(t); 
						printScaled(t);
						if (type(r) == (quint16)TEX_SPLIT_UP)
						{
							qint32 q = page_head; 
							t = 0;
							do
							{
								q = link(q);
								if ((type(q) == (quint16)TEX_INS_NODE) && (subtype(q) == (quint16)subtype(r)))
									t++;
							} while (q != broken_ins(r));
							
							print(", #"); 
							printInt(t); 
							print(tr(" might split"));
						}
						
						r = link(r);
					}
				}
			}
			
			if (link(contrib_head) != TEX_NULL)
				printnl(tr("### recent contributions:"));
		}
		
		showBox(link(nest[p].head_field));
		
		switch ((qAbs(m) / (TEX_MAX_COMMAND + 1)))
		{
			case 0:
				printnl(tr("prevdepth "));
				if (a.ii.CINT0 <= TEX_IGNORE_DEPTH)
					print(tr("ignored"));
				else
					printScaled(a.ii.CINT0);
				if (nest[p].pg_field != 0)
				{
					print(tr(", prevgraf "));
    				printInt(nest[p].pg_field); 
    				print(tr(" line"));
    				if (nest[p].pg_field != 1)
    					printChar('s');
				}
				break;
				
			case 1:
				printnl(tr("spacefactor ")); 
				printInt(a.hh.v.LH);
				if (m > 0)
				{
					if (a.hh.v.RH > 0)
					{
						print(tr(", current language ")); 
						printInt(a.hh.v.RH);
					}
				}
				break;
				
			case 2:
				if (a.ii.CINT0 != TEX_NULL)
				{
					print(tr("this will be denominator of:")); 
					showBox(a.ii.CINT0);
				}
				break;
		}
	}
}

void XWTeX::showBox(qint32 p)
{
	depth_threshold = showBoxDepth();
	breadth_max = showBoxBreadth();
	if (breadth_max <= 0)
		breadth_max = 5;
		
	if ((pool_ptr + depth_threshold) >= pool_size)
		depth_threshold = pool_size - pool_ptr - 1;
		
	showNodeList(p);
	println();
}

void XWTeX::showContext()
{
	base_ptr = input_ptr;
	input_stack[base_ptr] = cur_input;
	qint32 nn = -1; 
	bool bottom_line = false;
	qint32 j = 0;
	qint32 m = 0;
	qint32 n = 0;
	qint32 l = 0;
	qint32 p = 0;
	while (true)
	{
		cur_input = input_stack[base_ptr];
		if ((state != TEX_TOKEN_LIST))
		{
			if ((texname > 19) || (base_ptr == 0))
				bottom_line = true;
		}
		
		if ((base_ptr == input_ptr) || 
			bottom_line || 
			(nn < errorContextLines()))
		{
			if ((base_ptr == input_ptr) || 
				(state != TEX_TOKEN_LIST) || 
				(token_type != TEX_BACKED_UP) || 
				(loc != TEX_NULL))
			{
				tally = 0;
				old_setting = selector;
				if (current_ocp_lstack > 0)
				{
					printnl(tr("OCP stack ")); 
					printScaled(current_ocp_lstack);
        			print(tr(" entry ")); 
        			printInt(current_ocp_no); 
        			print(":");
        			l = tally; 
					tally = 0; 
					selector = TEX_PSEUDO;
  					trick_count = 1000000;
  					if (buffer[limit] == endLineChar())
  						j = limit;
  					else
  						j = limit + 1;
  						
  					if (j > 0)
  					{
  						for (qint32 i = texstart; i < j; i++)
  						{
  							if (i == loc)
  								setTrickCount();
  								
  							print(buffer[i]);
  						}
  					}
				}
				else if (state != TEX_TOKEN_LIST)
				{
					if (texname <= 17)
					{
						if (terminal_input)
						{
							if (base_ptr == 0)
								printnl("<*>");
							else
								printnl(tr("<insert> "));
						}
						else
						{
							printnl(tr("<read "));
							if (texname == 17)
								printChar('*');
							else
								printInt(texname - 1);
								
							printChar('>');
						}
					}
					else if (index != in_open)
					{
						printnl("l."); 
						printInt(line_stack[index + 1]);
					}
					else
					{
						printnl("l."); 
						printInt(line);
					}
					
					printChar(' ');
					
					l = tally; 
					tally = 0; 
					selector = TEX_PSEUDO;
  					trick_count = 1000000;
  					if (buffer[limit] == endLineChar())
  						j = limit;
  					else
  						j = limit + 1;
  						
  					if (j > 0)
  					{
  						for (qint32 i = texstart; i < j; i++)
  						{
  							if (i == loc)
  								setTrickCount();
  								
  							print(buffer[i]);
  						}
  					}
				}
				else
				{
					switch (token_type)
					{
						case TEX_PARAMETER: 
							printnl(tr("<argument> "));
							break;
							
						case TEX_U_TEMPLATE:
						case TEX_V_TEMPLATE: 
							printnl(tr("<template> "));
							break;
							
						case TEX_BACKED_UP: 
							if (loc == TEX_NULL) 
								printnl(tr("<recently read> "));
  							else 
  								printnl(tr("<to be read again> "));
  							break;
  							
						case TEX_INSERTED: 
							printnl(tr("<inserted text> "));
							break;
							
						case TEX_MACRO: 
							println(); 
							printCS(texname);
  							break;
  							
						case TEX_OUTPUT_TEXT: 
							printnl(tr("<output> "));
							break;
							
						case TEX_EVERY_PAR_TEXT: 
							printnl(tr("<everypar> "));
							break;
							
						case TEX_EVERY_MATH_TEXT: 
							printnl(tr("<everymath> "));
							break;
							
						case TEX_EVERY_DISPLAY_TEXT: 
							printnl(tr("<everydisplay> "));
							break;
							
						case TEX_EVERY_HBOX_TEXT: 
							printnl(tr("<everyhbox> "));
							break;
							
						case TEX_EVERY_VBOX_TEXT: 
							printnl(tr("<everyvbox> "));
							break;
							
						case TEX_EVERY_JOB_TEXT: 
							printnl(tr("<everyjob> "));
							break;
							
						case TEX_EVERY_CR_TEXT: 
							printnl(tr("<everycr> "));
							break;
							
						case TEX_EVERY_EOF_TEXT: 
							printnl(tr("<everyeof> "));
							break;
							
						case TEX_MARK_TEXT: 
							printnl(tr("<mark> "));
							break;
							
						case TEX_WRITE_TEXT: 
							printnl(tr("<write> "));
							break;
							
						default: 
							printnl("?");
					}
					
					l = tally; 
					tally = 0; 
					selector = TEX_PSEUDO;
  					trick_count = 1000000;
  					if (token_type < TEX_MACRO)
  						showTokenList(texstart, loc, 100000);
  					else
  						showTokenList(link(texstart), loc, 100000);
				}
				
				selector = old_setting;
				if (trick_count == 1000000)
					setTrickCount();
					
				if (tally < trick_count)
					m = tally - first_count;
				else
					m = trick_count-first_count;
					
				if (l + first_count <= half_error_line)
				{
					p = 0; 
					n = l + first_count;
				}
				else
				{
					print("..."); 
					p = l + first_count - half_error_line + 3;
  					n = half_error_line;
				}
				
				qint32 q = p;
				for (; q < first_count; q++)
					printChar(trick_buf[q % error_line]);
					
				println();
				q = 1;
				for (; q <= n; q++)
					printChar(' ');
					
				if ((m + n) <= error_line)
					p = first_count + m;
				else
					p = first_count + (error_line - n - 3);
					
				for (q = first_count; q < p; q++)
					printChar(trick_buf[q % error_line]);
					
				if ((m + n) > error_line)
					print("...");
					
				nn++;
			}
		}
		else if (nn == errorContextLines())
		{
			printnl("..."); 
			nn++;
		}
		
		if (bottom_line)
			goto done;
			
		base_ptr--;
	}
done:
	cur_input = input_stack[input_ptr];
}

void XWTeX::showCurCmdChr()
{
	beginDiagnostic(); 
	printnl("{");
	if (mode != shown_mode)
	{
		printMode(mode); 
		print(": "); 
		shown_mode = mode;
	}
	
	printCmdChr((quint16)cur_cmd, cur_chr);
	if (tracingIfs() > 0)
	{
		qint32 n, l;
		if (cur_cmd >= TEX_IF_TEST)
		{
			if (cur_cmd <= TEX_FI_OR_ELSE)
			{
				print(": ");
				if (cur_cmd == TEX_FI_OR_ELSE)
				{
					printCmdChr((quint16)TEX_IF_TEST, cur_if); 
					printChar(' ');
      				n = 0; 
      				l = if_line;
				}
				else
				{
					n = 1; 
					l = line;
				}
				
				qint32 p = cond_ptr;
				while (p != TEX_NULL)
				{
					n++; 
					p = link(p);
				}
				
				print(tr("(level ")); 
				printInt(n); 
				printChar(')'); 
				printIfLine(l);
			}
		}
	}
	
	printChar('}');
	endDiagnostic(false);
}

#ifdef XW_TEX_STAT
void XWTeX::showEqtb(qint32 n)
{
	if (n < TEX_ACTIVE_BASE)
		printChar('?');
	else if (n < TEX_GLUE_BASE)
	{
		sprintCS(n); 
		printChar('='); 
		printCmdChr((quint16)eqType(n), equiv(n));
		if (eqType(n) >= TEX_CALL)
		{
			printChar(':'); 
			showTokenList(link(equiv(n)), TEX_NULL, 32);
		}
	}
	else if (n < TEX_LOCAL_BASE)
	{
		if ( n < TEX_SKIP_BASE)
		{
			printSkipParam(n - TEX_GLUE_BASE); 
			printChar('=');
			if (n < (TEX_GLUE_BASE + TEX_THIN_MU_SKIP_CODE))
				printSpec(equiv(n), "pt");
			else
				printSpec(equiv(n), "mu");
		}
		else if (n < TEX_MU_SKIP_BASE)
		{
			printEsc(TeXSkip); 
			printInt(n - TEX_SKIP_BASE); 
			printChar('=');
  			printSpec(equiv(n), "pt");
		}
		else
		{
			printEsc(TeXMuSkip); 
			printInt(n - TEX_MU_SKIP_BASE); 
			printChar('=');
  			printSpec(equiv(n), "mu");
		}
	}
	else if (n < TEX_INT_BASE)
	{
		if (n < TEX_TOKEN_BASE)
		{
			printCmdChr((quint16)TEX_SET_SHAPE, n); 
			printChar('=');
			if (equiv(n) == TEX_NULL)
				printChar('0');
			else if (n > TEX_PAR_SHAPE_LOC)
			{
				printInt(penalty(equiv(n))); 
				printChar(' ');
				printInt(penalty(equiv(n) + 1));
				if (penalty(equiv(n)) > 1)
					printEsc(TeXETC);
			}
			else
				printInt(info(parShapePtr()));
		}
		else if (n < TEX_TOKS_BASE)
		{
			printCmdChr((quint16)TEX_ASSIGN_TOKS, n); 
			printChar('=');
			if (equiv(n) != TEX_NULL)
				showTokenList(link(equiv(n)), TEX_NULL, 32);
		}
		else if (n < TEX_BOX_BASE)
		{
			printEsc(TeXToks); 
			printInt(n - TEX_TOKS_BASE); 
			printChar('=');
			if (equiv(n) != TEX_NULL)
				showTokenList(link(equiv(n)), TEX_NULL, 32);
		}
		else if (n < TEX_CUR_FONT_LOC)
		{
			printEsc(TeXBox); 
			printInt(n - TEX_BOX_BASE); 
			printChar('=');
			if (equiv(n) == TEX_NULL)
				print("void");
			else
			{
				depth_threshold = 0; 
				breadth_max = 1; 
				showNodeList(equiv(n));
			}
		}
		else if (n < TEX_CAT_CODE_BASE)
		{
			if (n == TEX_CUR_FONT_LOC)
				print(tr("current font"));
			else if (n < (TEX_MATH_FONT_BASE + TEX_SCRIPT_SIZE))
			{
				printEsc(TeXTextFont); 
				printInt(n - TEX_MATH_FONT_BASE);
			}
			else if (n < (TEX_MATH_FONT_BASE + TEX_SCRIPT_SCRIPT_SIZE))
			{
				printEsc(TeXScriptFont); 
				printInt(n - TEX_MATH_FONT_BASE - TEX_SCRIPT_SIZE);
			}
			else
			{
				printEsc(TeXScriptScriptFont);
  				printInt(n - TEX_MATH_FONT_BASE - TEX_SCRIPT_SCRIPT_SIZE);
			}
			
			printChar('=');
			printEsc(newText(TEX_FONT_ID_BASE + equiv(n)));
		}
		else
		{
			if (n < TEX_MATH_CODE_BASE)
			{
				if (n < TEX_LC_CODE_BASE)
				{
					printEsc(TeXCatCode); 
					printInt(n - TEX_CAT_CODE_BASE);
				}
				else if (n < TEX_UC_CODE_BASE)
				{
					printEsc(TeXLcCode); 
					printInt(n - TEX_LC_CODE_BASE);
				}
				else if (n < TEX_SF_CODE_BASE)
				{
					printEsc(TeXUcCode); 
					printInt(n - TEX_UC_CODE_BASE);
				}
				else
				{
					printEsc(TeXSfCode); 
					printInt(n - TEX_SF_CODE_BASE);
				}
				printChar('='); 
				printInt(equiv(n));
			}
			else
			{
				printEsc(TeXMathCode); 
				printInt(n - TEX_MATH_CODE_BASE);
  				printChar('='); 
  				printInt(equiv(n));
			}
		}
	}
	else if (n < TEX_DIMEN_BASE)
	{
		if (n < TEX_COUNT_BASE)
			printParam(n - TEX_INT_BASE);
		else if (n < TEX_DEL_CODE_BASE)
		{
			printEsc(TeXCount); 
			printInt(n - TEX_COUNT_BASE);
		}
		else
		{
			printEsc(TeXDelCode); 
			printInt(n - TEX_DEL_CODE_BASE);
		}
		
		printChar('='); 
		printInt(newEqtbInt(n));
	}
	else if (n <= TEX_EQTB_SIZE)
	{
		if (n < TEX_SCALED_BASE)
			printLengthParam(n - TEX_DIMEN_BASE);
		else
		{
			printEsc(TeXDimen); 
			printInt(n - TEX_SCALED_BASE);
		}
		
		printChar('='); 
		printScaled(newEqtbSC(n)); 
		print("pt");
	}
	else
		printChar('?');
}
#endif //XW_TEX_STAT

void  XWTeX::showInfo()
{
	showNodeList(info(temp_ptr));
}

void XWTeX::showNodeList(qint32 p)
{
	if (curLength() > depth_threshold)
	{
		if (p > TEX_NULL)
		{
			print(" []");
			return ;
		}
	}
	
	qint32 n = 0;
	while (p > mem_min)
	{
		println(); 
		printCurrentString();
		if (p > mem_end)
		{
			print(tr("Bad link, display aborted.")); 
			return;
		}
		n++;
		if (n > breadth_max)
		{
			print(tr("etc.")); 
			return;
		}
		
		if (isCharNode(p))
			printFontAndChar(p);
		else
		{
			switch (type(p))
			{
				case TEX_HLIST_NODE:
				case TEX_VLIST_NODE:
				case TEX_UNSET_NODE:
					if (type(p) == (quint16)TEX_HLIST_NODE)
						printEsc(TeXH);
					else if (type(p) == (quint16)TEX_VLIST_NODE)
						printEsc(TeXV);
					else
						printEsc(TeXUnset);
					print(tr("box(")); 
					printScaled(height(p)); 
					printChar('+');
					printScaled(depth(p)); 
					print(")x"); 
					printScaled(width(p));
					if (type(p) == (quint16)TEX_UNSET_NODE)
					{
						if (span_count(p) != (quint16)TEX_MIN_QUARTERWORD)
						{
							print(" ("); 
							printInt((span_count(p)) + 1);
  							print(tr(" columns)"));
						}
						
						if (glue_stretch(p) != 0)
						{
							print(tr(", stretch ")); 
							printGlue(glue_stretch(p), glue_order(p), 0);
						}
						
						if (glue_shrink(p) != 0)
						{
							print(tr(", shrink ")); 
							printGlue(glue_shrink(p), glue_sign(p), 0);
						}
					}
					else
					{
						double g = glue_set(p);
						if ((g != 0.0) && (glue_sign(p) != (quint16)TEX_NORMAL))
						{
							print(tr(", glue set "));
							if (glue_sign(p) == (quint16)TEX_SHRINKING)
								print("- ");
								
							if (qAbs(g) > 20000.0)
							{
								if (g > 0.0)
									printChar('>');
								else 
									print("< -");
									
								printGlue(20000 * TEX_UNITY, glue_order(p), 0);
							}
							else
								printGlue(round(TEX_UNITY * g), glue_order(p), 0);
						}
						
						if (shift_amount(p) != 0)
						{
							print(tr(", shifted ")); 
							printScaled(shift_amount(p));
						}
						
						print(tr(", direction ")); 
						printDir(box_dir(p));
					}
					nodeListDisplay(list_ptr(p));
					break;
					
				case TEX_RULE_NODE:
					printEsc("rule("); 
					printRuleDimen(height(p)); 
					printChar('+');
					printRuleDimen(depth(p)); 
					print(")x"); 
					printRuleDimen(width(p));
					break;
					
				case TEX_INS_NODE:
					printEsc(TeXInsert); 
					printInt(subtype(p));
					print(tr(", natural size ")); 
					printScaled(height(p));
					print(tr("; split(")); 
					printSpec(split_top_ptr(p), 0);
					printChar(','); 
					printScaled(depth(p));
					print(tr("); float cost ")); 
					printInt(float_cost(p));
					nodeListDisplay(ins_ptr(p));
					break;
					
				case TEX_WHATSIT_NODE:
					{
						switch (subtype(p))
						{
							case TEX_OPEN_NODE:
								printWriteWhatsIt(TeXOpenOut, p);
								printChar('='); 
								printFileName(open_name(p), open_area(p), open_ext(p));
								break;
								
							case TEX_WRITE_NODE:
								printWriteWhatsIt(TeXWrite, p);
  								printMark(write_tokens(p));
								break;
								
							case TEX_CLOSE_NODE:
								printWriteWhatsIt(TeXCloseOut, p);
								break;
								
							case TEX_SPECIAL_NODE:
								printEsc(TeXSpecial);
  								printMark(write_tokens(p));
								break;
								
							case TEX_LANGUAGE_NODE:
								printEsc(TeXSetLanguage);
  								printInt(what_lang(p)); 
  								print(tr(" (hyphenmin "));
  								printInt(what_lhm(p)); 
  								printChar(',');
  								printInt(what_rhm(p)); 
  								printChar(')');
								break;
								
							case TEX_DIR_NODE:
								if (dir_dir(p) < 0)
								{
									printEsc(TeXEndDir); 
									print(" "); 
									printDir(dir_dir(p) + 64);
								}
								else
								{
									printEsc(TeXBeginDir); 
									print(" "); 
									printDir(dir_dir(p));
								}
								break;
								
							case TEX_LOCAL_PAR_NODE:
								printEsc(TeXWhatsit);
  								appendChar('.');
  								println(); 
  								printCurrentString();
  								printEsc(TeXLocalInterLinePenalty); 
  								print("=");
  								printInt(local_pen_inter(p));
  								println(); 
  								printCurrentString();
  								printEsc(TeXLocalBrokenPenalty); 
  								print("=");
  								printInt(local_pen_broken(p));
  								println(); 
  								printCurrentString();
  								printEsc(TeXLocalLeftBox);
  								if (local_box_left(p) == TEX_NULL)
  									print("=null");
  								else
  								{
  									appendChar('.');
    								showNodeList(local_box_left(p));
    								pool_ptr--;
  								}
  								println(); 
  								printCurrentString();
  								printEsc(TeXLocalRightBox);
  								if (local_box_right(p) == TEX_NULL)
  									print("=null");
  								else
  								{
  									appendChar('.');
    								showNodeList(local_box_right(p));
    								pool_ptr--;
  								}
  								pool_ptr--;
								break;
								
							default:
								print("whatsit?");
								break;
						}
					}
					break;
					
				case TEX_GLUE_NODE:
					if (subtype(p) >= (quint16)TEX_A_LEADERS)
					{
						printEsc("");
						if (subtype(p) == (quint16)TEX_C_LEADERS)
							printChar('c');
						else if (subtype(p) == (quint16)TEX_X_LEADERS)
							printChar('x');
						print(tr("leaders ")); 
						printSpec(glue_ptr(p), 0);
						nodeListDisplay(leader_ptr(p));
					}
					else
					{
						printEsc(TeXGlue);
						if (subtype(p) != (quint16)TEX_NORMAL)
						{
							printChar('(');
							if (subtype(p) < (quint16)TEX_COND_MATH_GLUE)
								printSkipParam(subtype(p) - 1);
							else if (subtype(p) == (quint16)TEX_COND_MATH_GLUE)
								printEsc(TeXNonScript);
							else
								printEsc(TeXMSkip);
								
							printChar(')');
						}
						
						if (subtype(p) != (quint16)TEX_COND_MATH_GLUE)
						{
							printChar(' ');
							if (subtype(p) < (quint16)TEX_COND_MATH_GLUE)
								printSpec(glue_ptr(p), 0);
							else
								printSpec(glue_ptr(p), "mu");
						}
					}
					break;
					
				case TEX_KERN_NODE:
					if (subtype(p) != (quint16)TEX_MU_GLUE)
					{
						printEsc(TeXKern);
						if (subtype(p) != (quint16)TEX_NORMAL)
							printScaled(width(p));
						if (subtype(p) == (quint16)TEX_ACC_KERN)
							print(tr(" (for accent)"));
					}
					else
					{
						printEsc(TeXMKern); 
						printScaled(width(p)); 
						print("mu");
					}
					break;
					
				case TEX_MATH_NODE:
					printEsc(TeXMath);
					if (subtype(p) == (quint16)TEX_BEFORE)
						print("on");
					else
						print("off");
					if (width(p) != 0)
					{
						print(tr(", surrounded ")); 
						printScaled(width(p));
					}
					break;
					
				case TEX_LIGATURE_NODE:
					printFontAndChar(lig_char(p)); 
					print(tr(" (ligature "));
					if (subtype(p) > (quint16)1)
						printChar('|');
					font_in_short_display = font(lig_char(p)); 
					shortDisplay(lig_ptr(p));
					if (odd(subtype(p)))
						printChar('|');
					printChar(')');
					break;
					
				case TEX_PENALTY_NODE:
					printEsc(TeXPenalty); 
					printChar(' ');
					printInt(penalty(p));
					break;
					
				case TEX_DISC_NODE:
					printEsc(TeXDiscretionary);
					if (replace_count(p) > (quint16)0)
					{
						print(tr(" replacing ")); 
						printInt(replace_count(p));
					}
					nodeListDisplay(pre_break(p));
					appendChar('|'); 
					showNodeList(post_break(p)); 
					flushChar();
					break;
					
				case TEX_MARK_NODE:
					printEsc(TeXMark);
					if (mark_class(p) != 0)
					{
						printChar('s'); 
						printInt(mark_class(p));
					}
					printMark(mark_ptr(p));
					break;
					
				case TEX_ADJUST_NODE:
					printEsc(TeXVAdjust); 
					nodeListDisplay(adjust_ptr(p));
					break;
					
				case TEX_STYLE_NODE:
					printStyle(subtype(p));
					break;
					
				case TEX_CHOICE_NODE:
					printEsc(TeXMathChoice);
					appendChar('D'); 
					showNodeList(display_mlist(p)); 
					flushChar();
					appendChar('T'); 
					showNodeList(text_mlist(p)); 
					flushChar();
					appendChar('S'); 
					showNodeList(script_mlist(p)); 
					flushChar();
					appendChar('s'); 
					showNodeList(script_script_mlist(p)); 
					flushChar();
					break;
					
				case TEX_ORD_NOAD:
				case TEX_OP_NOAD:
				case TEX_BIN_NOAD:
				case TEX_REL_NOAD:
				case TEX_OPEN_NOAD:
				case TEX_CLOSE_NOAD:
				case TEX_PUNCT_NOAD:
				case TEX_INNER_NOAD:
				case TEX_RADICAL_NOAD:
				case TEX_OVER_NOAD:
				case TEX_UNDER_NOAD:
				case TEX_VCENTER_NOAD:
				case TEX_ACCENT_NOAD:
				case TEX_LEFT_NOAD:
				case TEX_RIGHT_NOAD:
					{
						switch (type(p))
						{
							case TEX_ORD_NOAD:
								printEsc(TeXMathOrd);
								break;
								
							case TEX_OP_NOAD:
								printEsc(TeXMathOp);
								break;
								
							case TEX_BIN_NOAD:
								printEsc(TeXMathBin);
								break;
								
							case TEX_REL_NOAD:
								printEsc(TeXMathRel);
								break;
								
							case TEX_OPEN_NOAD:
								printEsc(TeXMathOpen);
								break;
								
							case TEX_CLOSE_NOAD:
								printEsc(TeXMathClose);
								break;
								
							case TEX_PUNCT_NOAD:
								printEsc(TeXMathPunct);
								break;
								
							case TEX_INNER_NOAD:
								printEsc(TeXMathInner);
								break;
								
							case TEX_OVER_NOAD: 
								printEsc(TeXOverLine);
								break;
								
							case TEX_UNDER_NOAD:
								printEsc(TeXUnderLine);
								break;
								
							case TEX_VCENTER_NOAD: 
								printEsc(TeXVCenter);
								break;
								
							case TEX_RADICAL_NOAD:
								printEsc(TeXRadical); 
								printDelimiter(left_delimiter(p));
								break;
								
							case TEX_ACCENT_NOAD:
								printEsc(TeXAccent); 
								printFamAndChar(accent_chr(p));
								break;
								
							case TEX_LEFT_NOAD:
								printEsc(TeXLeft); 
								printDelimiter(nucleus(p));
								break;
								
							case TEX_RIGHT_NOAD:
								if (subtype(p) == (quint16)TEX_NORMAL)
									printEsc(TeXRight);
								else
									printEsc(TeXMiddle);
								printDelimiter(nucleus(p));
								break;
						}
						
						if (type(p) < (quint16)TEX_LEFT_NOAD)
						{
							if (subtype(p) != (quint16)TEX_NORMAL)
							{
								if (subtype(p) == (quint16)TEX_LIMITS)
									printEsc(TeXLimits);
								else
									printEsc(TeXNoLimits);
							}
							printSubsidiaryData(nucleus(p), '.');
						}
						
						printSubsidiaryData(supscr(p), '^');
						printSubsidiaryData(subscr(p), '_');
					}
					break;
					
				case TEX_FRACTION_NOAD:
					printEsc("fraction");
					print(", thickness ");
					if (thickness(p) == TEX_DEFAULT_CODE)
						print("= default");
					else
						printScaled(thickness(p));
					if ((small_fam(left_delimiter(p)) != (quint16)0) || 
						(small_char(left_delimiter(p)) != (quint16)TEX_MIN_QUARTERWORD) || 
						(large_fam(left_delimiter(p)) != (quint16)0) || 
						(large_char(left_delimiter(p)) != (quint16)TEX_MIN_QUARTERWORD))
					{
						print(", left-delimiter "); 
						printDelimiter(left_delimiter(p));
					}
					if ((small_fam(right_delimiter(p)) != (quint16)0) || 
						(small_char(right_delimiter(p)) != (quint16)TEX_MIN_QUARTERWORD) || 
						(large_fam(right_delimiter(p)) != (quint16)0) || 
						(large_char(right_delimiter(p)) != (quint16)TEX_MIN_QUARTERWORD))
					{
						print(", right-delimiter "); 
						printDelimiter(right_delimiter(p));
					}
					printSubsidiaryData(numerator(p),'\\');
					printSubsidiaryData(denominator(p),'/');
					break;
					
				default:
					print(tr("Unknown node type!"));
					break;
			}
		}
		
		p = link(p);
	}
}

void XWTeX::showSaveGroups()
{
	qint32 p, m, v, l, c, a, i, j, s;
	
	p = nest_ptr; 
	nest[p] = cur_list;
	v = save_ptr; 
	l = cur_level; 
	c = cur_group;
	save_ptr = cur_boundary; 
	cur_level--;
	a = 1;
	printnl(""); 
	println();
	
	while (true)
	{
		printnl("### "); 
		printGroup(true);
		if (cur_group == TEX_BOTTOM_LEVEL)
			goto done;
			
		do
		{
			m = nest[p].mode_field;
			if (p > 0)
				p--;
			else
				m = TEX_VMODE;
		} while (m == TEX_HMODE);
		print(" (");
		switch (cur_group)
		{
			case TEX_SIMPLE_GROUP:
				p++;
				goto found2;
				break;
				
			case TEX_HBOX_GROUP:
			case TEX_ADJUSTED_HBOX_GROUP: 
				s = TeXHBox;
				break;
				
    		case TEX_VBOX_GROUP: 
    			s = TeXVBox;
    			break;
    			
    		case TEX_VTOP_GROUP: 
    			s= TeXVTop;
    			break;
    			
    		case TEX_ALIGN_GROUP:
    			if (a == 0)
    			{
    				if (m == -TEX_VMODE)
    					s = TeXHAlign;
    				else
    					s = TeXVAlign;
    					
    				a = 1; 
    				goto found1;
    			}
    			else
    			{
    				if (a == 1)
    					print(tr("align entry"));
    				else
    					printEsc(TeXCr);
    					
    				if (p >= a)
    					p = p - a;
    					
    				a = 0; 
    				goto found;
    			}
    			break;
    			
    		case TEX_NO_ALIGN_GROUP:
    			p++; 
    			a = -1; 
    			printEsc(TeXNoAlign); 
    			goto found2;
    			break;
    			
    		case TEX_OUTPUT_GROUP:
    			printEsc(TeXOutput); 
    			goto found;
    			break;
    			
    		case TEX_MATH_GROUP: 
    			goto found2;
    			break;
    			
    		case TEX_DISC_GROUP:
    		case TEX_MATH_CHOICE_GROUP:
    			if (cur_group == TEX_DISC_GROUP)
    				printEsc(TeXDiscretionary);
    			else
    				printEsc(TeXMathChoice);
    			for (i = 0; i <= 3; i++)
    			{
    				if (i <= saved(-2))
    					print("{}");
    			}
    			goto found2;
    			break;
    			
    		case TEX_INSERT_GROUP:
    			if (saved(-2) == 255)
    				printEsc(TeXVAdjust);
    			else
    			{
    				printEsc(TeXInsert); 
    				printInt(saved(-2));
    			}
    			goto found2;
    			break;
    			
    		case TEX_VCENTER_GROUP:
    			s = TeXVCenter; 
    			goto found1;
    			break;
    			
    		case TEX_SEMI_SIMPLE_GROUP:
    			p++; 
    			printEsc(TeXBeginGroup); 
    			goto found;
    			break;
    			
    		case TEX_MATH_SHIFT_GROUP:
    			if (m == TEX_MMODE)
    				printChar('$');
    			else if (nest[p].mode_field == TEX_MMODE)
    			{
    				printCmdChr((quint16)TEX_EQ_NO, saved(-2)); 
    				goto found;
    			}
    			printChar('$');
    			goto found;
    			break;
    			
    		case TEX_MATH_LEFT_GROUP:
    			if (type(nest[p + 1].eTeX_aux_field) == (quint16)TEX_LEFT_NOAD)
    				printEsc(TeXLeft);
    			else
    				printEsc(TeXMiddle);
    			goto found;
    			break;
    			
    		default:
    			break;
		}
		
		i = saved(-4);
		if (i != 0)
		{
			if (i < TEX_BOX_FLAG)
			{
				if (qAbs(nest[p].mode_field) == TEX_VMODE)
					j = TEX_HMOVE;
				else
					j = TEX_VMOVE;
					
				if (i > 0)
					printCmdChr((quint16)j, 0);
				else
					printCmdChr((quint16)j, 1);
					
				printScaled(qAbs(i)); 
				print(TeXPT);
			}
			else if (i < TEX_SHIP_OUT_FLAG)
			{
				if (i >= TEX_GLOBAL_BOX_FLAG)
				{
					printEsc(TeXGlobal); 
					i = i - (TEX_GLOBAL_BOX_FLAG - TEX_BOX_FLAG);
				}
				
				printEsc(TeXSetBox); 
				printInt(i - TEX_BOX_FLAG); 
				printChar('=');
			}
			else
				printCmdChr((quint16)TEX_LEADER_SHIP, i - (TEX_LEADER_FLAG - TEX_A_LEADERS));
		}
		
found1:
		printEsc(s);
		if (saved(-2) != 0)
		{
			printChar(' ');
			if (saved(-3) == TEX_EXACTLY)
				print(TeXTo);
			else
				print(TeXSpread);
				
			printScaled(saved(-2)); 
			print(TeXPT);
		}
		
found2: 
		printChar('{');
		
found: 
		printChar(')'); 
		cur_level--;
		cur_group = save_level(save_ptr); 
		save_ptr = save_index(save_ptr);
	}
	
done: 
	save_ptr = v; 
	cur_level = l; 
	cur_group = c;
}

#ifdef XW_TEX_STAT
void XWTeX::showSa(qint32 , const QString & s)
{
	beginDiagnostic(); 
	printChar('{'); 
	print(s); 
	printChar(' ');	
	printChar('}'); 
	endDiagnostic(false);
}
#endif //XW_TEX_STAT

void XWTeX::showTokenList(qint32 p, qint32 q, qint32 l)
{
	qint32 match_chr = '#'; 
	qint32 n = '0'; 
	qint32 c = 0;
	tally = 0;
	qint32 m = 0;
	while ((p != TEX_NULL) && (tally < l))
	{
		if (p == q)
			setTrickCount();
			
		if ((p < hi_mem_min) || (p > mem_end))
		{
			printEsc(TeXCLOBBERED); 
			return;
		}
		
		if (info(p) >= TEX_CS_TOKEN_FLAG)
			printCS(info(p) - TEX_CS_TOKEN_FLAG);
		else
		{
			m = info(p) / TEX_MAX_CHAR_VAL; 
			c = info(p) % TEX_MAX_CHAR_VAL;
		
			if (info(p) < 0)
				printEsc(TeXBad);
			else
			{
				switch (m)
				{
					case TEX_LEFT_BRACE:
					case TEX_RIGHT_BRACE:
					case TEX_MATH_SHIFT:
					case TEX_TAB_MARK:
					case TEX_SUP_MARK:
					case TEX_SUB_MARK:
					case TEX_SPACER:
  					case TEX_LETTER:
  					case TEX_OTHER_CHAR: 
  						print(c);
  						break;
  					
					case TEX_MAC_PARAM: 
						print(c); 
						print(c);
  						break;
  					
					case TEX_OUT_PARAM: 
						print(match_chr);
  						if (c <= 9) 
  							printChar(c + '0');
  						else
  						{  
  							printChar('!'); 
  							return;
  						}
    					break;
    				
					case TEX_MATCH: 
						match_chr = c; 
						print(c); 
						n++; 
						printChar(n);
  						if (n > '9') 
  							return;
  						break;
  					
					case TEX_END_MATCH: 
						if (c == 0) 
							print("->");
						break;
					
					default:
						printEsc(TeXBad);
						break;
				}
			}
		}
		
		p = link(p);
	}
	
	if (p != TEX_NULL)
		printEsc(TeXETC);
}

void XWTeX::showWhatEver()
{
	qint32 p, t, m, l, n;
	
	switch (cur_chr)
	{
		case TEX_SHOW_LISTS:
			beginDiagnostic(); 
			showActivities();
			break;
			
		case TEX_SHOW_BOX_CODE:
			scanEightBitInt(); 
			beginDiagnostic();
			printnl("> \\box"); 
			printInt(cur_val); 
			printChar('=');
			if (box(cur_val) == TEX_NULL)
				print("void");
			else
				showBox(box(cur_val));
			break;
			
		case TEX_SHOW_CODE:
			getToken();
			printnl("> ");
			if (cur_cs != 0)
			{
				sprintCS(cur_cs); 
				printChar('=');
			}
			printMeaning(); 
			goto common_ending;
			break;
			
		case TEX_SHOW_GROUPS:
			beginDiagnostic(); 
			showSaveGroups();
			break;
			
		case TEX_SHOW_IFS:
			beginDiagnostic(); 
			printnl(""); 
			println();
			if (cond_ptr == TEX_NULL)
			{
				printnl("### "); 
				print(tr("no active conditionals"));
			}
			else
			{
				p = cond_ptr; 
				n = 0;
				do
				{
					n++; 
					p = link(p);
				} while (p != TEX_NULL);
				
				p = cond_ptr; 
				t = cur_if; 
				l = if_line; 
				m = if_limit;
				
				do
				{
					printnl("### level "); 
					printInt(n); 
					print(": ");
    				printCmdChr((quint16)TEX_IF_TEST, t);
    				if (m == TEX_FI_CODE)
    					printEsc(TeXElse);
    						
    				printIfLine(l);
    				n--; 
    				t = subtype(p); 
    				l = if_line_field(p); 
    				m = type(p); 
    				p = link(p);
				} while (p != TEX_NULL);
			}
			break;
			
		default:
			p = theToks();
			printnl("> "); 
			tokenShow(temp_head);
			flushList(link(temp_head)); 
			goto common_ending;
			break;
	}
	
	endDiagnostic(true); 
	printErr("OK");
	if (selector == TEX_TERM_AND_LOG)
	{
		if (tracingOnline() <= 0)
		{
			selector = TEX_TERM_ONLY; 
			print(tr(" (see the transcript file)"));
  			selector = TEX_TERM_AND_LOG;
		}
	}
	
common_ending:
	if (interaction < TEX_ERROR_STOP_MODE)
	{
		help0(); 
		error_count--;
	}
	else if (tracingOnline() > 0)
	{
		help3(tr("This isn't an error message; I'm just \\showing something."));
		help_line[1] = tr("Type `I\\show...' to show more (e.g., \\show\\cs,");
		help_line[0] = tr("\\showthe\\count10, \\showbox255, \\showlists).");
	}
	else
	{
		help5(tr("This isn't an error message; I'm just \\showing something."));
		help_line[3] = tr("Type `I\\show...' to show more (e.g., \\show\\cs,");
		help_line[2] = tr("\\showthe\\count10, \\showbox255, \\showlists).");
		help_line[1] = tr("And type `I\\tracingonline=1\\show...' to show boxes and");
		help_line[0] = tr("lists on your terminal as well as in the transcript file.");
	}
	error();
}

void XWTeX::slowPrint(qint32 s)
{
	if ((s >= str_ptr) || (s <= TEX_BIGGEST_CHAR))
		print(s);
	else
		omegaPrint(s);
}

void XWTeX::sprintCS(qint32 p)
{
	if (p < TEX_HASH_BASE)
	{
		if (p < TEX_SINGLE_BASE)
			print(p - TEX_ACTIVE_BASE);
		else	if (p < TEX_NULL_CS)
			printEsc(p - TEX_SINGLE_BASE);
		else
		{
			printEsc(TeXCsName); 
			printEsc(TeXEndCsName);
		}
	}
	else
		printEsc(newText(p));
}

void XWTeX::tokenShow(qint32 p)
{
	if (p != TEX_NULL)
		showTokenList(link(p), TEX_NULL, 10000000);
}
